<channel>
  <id>0211cef5-3594-405d-9112-2aef045d5bec</id>
  <name>01_PHIX_CANCER</name>
  <description></description>
  <enabled>false</enabled>
  <version>2.2.0.5828</version>
  <lastModified>
    <time>1328161911233</time>
    <timezone>America/New_York</timezone>
  </lastModified>
  <revision>2</revision>
  <sourceConnector>
    <name>sourceConnector</name>
    <properties>
      <property name="DataType">Channel Reader</property>
      <property name="responseValue">None</property>
    </properties>
    <transformer>
      <steps>
        <step>
          <sequenceNumber>0</sequenceNumber>
          <name>Set PHIX instance-specific variables</name>
          <script>logger.info(&quot;PHIX VERSION: 1.3.1.0&quot;);
channelMap.put(&apos;phix_version&apos;, &apos;1.3.1.0&apos;);

/* Production Values 
// PHIX instance-specific variables
logger.info(&quot;PHIX INSTANCE-SPECIFIC CONFIGURATION:&quot;);

logger.info(&quot;hubInstanceName: &quot; + &quot;PHIX 1&quot;);
logger.info(&quot;hubHost: &quot; + &quot;phix1.phiresearchlab.org&quot;);
logger.info(&quot;hubInstanceEmailFromAddr: &quot; + &quot;administrator@phix1.phiresearchlab.org&quot;);
logger.info(&quot;hubInstanceWebSvcHost: &quot; + &quot;phix1.phiresearchlab.org:8081&quot;);
logger.info(&quot;enablePHIXPortalConnector: &quot; + &quot;false&quot;);

// &quot;PHIX 1&quot; Configuration
channelMap.put(&apos;hubInstanceName&apos;, &apos;PHIX 1&apos;);
channelMap.put(&apos;hubHost&apos;, &apos;phix1.phiresearchlab.org&apos;);
channelMap.put(&apos;hubInstanceEmailFromAddr&apos;, &apos;administrator@phix1.phiresearchlab.org&apos;);
channelMap.put(&apos;hubInstanceWebSvcHost&apos;, &apos;phix1.phiresearchlab.org:8081&apos;)
channelMap.put(&apos;enablePHIXPortalConnector&apos;, &apos;false&apos;);


// &quot;PHIX 2&quot; Configuration
//channelMap.put(&apos;hubInstanceName&apos;, &apos;PHIX 2&apos;);
//channelMap.put(&apos;hubHost&apos;, &apos;phix2.phiresearchlab.org&apos;);
//channelMap.put(&apos;hubInstanceEmailFromAddr&apos;, &apos;administrator@phix2.phiresearchlab.org&apos;);
//channelMap.put(&apos;hubInstanceWebSvcHost&apos;, &apos;phix2.phiresearchlab.org:8081&apos;);
//channelMap.put(&apos;enablePHIXPortalConnector&apos;, &apos;false&apos;);
*/
// Hub instance-specific variables
logger.info(&apos;HUB INSTANCE-SPECIFIC CONFIGURATION:&apos;);

logger.info(&apos;hubInstanceName: &apos; + &apos;PHLISSA HUB 1&apos;);
logger.info(&apos;hubHost: &apos; + &apos;atlphix01.dhcp.saic.com&apos;);
logger.info(&apos;hubInstanceEmailFromAddr: &apos; + &apos;administrator@atlphix01.dhcp.saic.com&apos;);
logger.info(&apos;hubInstanceWebSvcHost: &apos; + &apos;atlphix01.dhcp.saic.com:8081&apos;);
logger.info(&apos;enablePHIXPortalConnector: &apos; + &apos;false&apos;);

// phlissa-hub1 configuration (&apos;HUB 1&apos;)
channelMap.put(&apos;hubInstanceName&apos;, &apos;PHLISSA HUB 1&apos;);
channelMap.put(&apos;hubHost&apos;, &apos;atlphix01.dhcp.saic.com&apos;);
channelMap.put(&apos;hubInstanceEmailFromAddr&apos;, &apos;administrator@atlphix01.dhcp.saic.com&apos;);
channelMap.put(&apos;hubInstanceWebSvcHost&apos;, &apos;atlphix01.dhcp.saic.com:8081&apos;)
channelMap.put(&apos;enablePHIXPortalConnector&apos;, &apos;false&apos;);

// dejongp configuration (&apos;HUB 2&apos;)
//channelMap.put(&apos;hubInstanceName&apos;, &apos;PHLISSA HUB 2&apos;);
//channelMap.put(&apos;hubHost&apos;, &apos;dejongp.us.saic.com&apos;);
//channelMap.put(&apos;hubInstanceEmailFromAddr&apos;, &apos;administrator@dejongp.us.saic.com&apos;);
//channelMap.put(&apos;hubInstanceWebSvcHost&apos;, &apos;dejongp.us.saic.com:8081&apos;);
//channelMap.put(&apos;enablePHIXPortalConnector&apos;, &apos;true&apos;);</script>
          <type>JavaScript</type>
          <data class="map">
            <entry>
              <string>Script</string>
              <string>logger.info(&quot;PHIX VERSION: 1.3.1.0&quot;);
channelMap.put(&apos;phix_version&apos;, &apos;1.3.1.0&apos;);

/* Production Values 
// PHIX instance-specific variables
logger.info(&quot;PHIX INSTANCE-SPECIFIC CONFIGURATION:&quot;);

logger.info(&quot;hubInstanceName: &quot; + &quot;PHIX 1&quot;);
logger.info(&quot;hubHost: &quot; + &quot;phix1.phiresearchlab.org&quot;);
logger.info(&quot;hubInstanceEmailFromAddr: &quot; + &quot;administrator@phix1.phiresearchlab.org&quot;);
logger.info(&quot;hubInstanceWebSvcHost: &quot; + &quot;phix1.phiresearchlab.org:8081&quot;);
logger.info(&quot;enablePHIXPortalConnector: &quot; + &quot;false&quot;);

// &quot;PHIX 1&quot; Configuration
channelMap.put(&apos;hubInstanceName&apos;, &apos;PHIX 1&apos;);
channelMap.put(&apos;hubHost&apos;, &apos;phix1.phiresearchlab.org&apos;);
channelMap.put(&apos;hubInstanceEmailFromAddr&apos;, &apos;administrator@phix1.phiresearchlab.org&apos;);
channelMap.put(&apos;hubInstanceWebSvcHost&apos;, &apos;phix1.phiresearchlab.org:8081&apos;)
channelMap.put(&apos;enablePHIXPortalConnector&apos;, &apos;false&apos;);


// &quot;PHIX 2&quot; Configuration
//channelMap.put(&apos;hubInstanceName&apos;, &apos;PHIX 2&apos;);
//channelMap.put(&apos;hubHost&apos;, &apos;phix2.phiresearchlab.org&apos;);
//channelMap.put(&apos;hubInstanceEmailFromAddr&apos;, &apos;administrator@phix2.phiresearchlab.org&apos;);
//channelMap.put(&apos;hubInstanceWebSvcHost&apos;, &apos;phix2.phiresearchlab.org:8081&apos;);
//channelMap.put(&apos;enablePHIXPortalConnector&apos;, &apos;false&apos;);
*/
// Hub instance-specific variables
logger.info(&apos;HUB INSTANCE-SPECIFIC CONFIGURATION:&apos;);

logger.info(&apos;hubInstanceName: &apos; + &apos;PHLISSA HUB 1&apos;);
logger.info(&apos;hubHost: &apos; + &apos;atlphix01.dhcp.saic.com&apos;);
logger.info(&apos;hubInstanceEmailFromAddr: &apos; + &apos;administrator@atlphix01.dhcp.saic.com&apos;);
logger.info(&apos;hubInstanceWebSvcHost: &apos; + &apos;atlphix01.dhcp.saic.com:8081&apos;);
logger.info(&apos;enablePHIXPortalConnector: &apos; + &apos;false&apos;);

// phlissa-hub1 configuration (&apos;HUB 1&apos;)
channelMap.put(&apos;hubInstanceName&apos;, &apos;PHLISSA HUB 1&apos;);
channelMap.put(&apos;hubHost&apos;, &apos;atlphix01.dhcp.saic.com&apos;);
channelMap.put(&apos;hubInstanceEmailFromAddr&apos;, &apos;administrator@atlphix01.dhcp.saic.com&apos;);
channelMap.put(&apos;hubInstanceWebSvcHost&apos;, &apos;atlphix01.dhcp.saic.com:8081&apos;)
channelMap.put(&apos;enablePHIXPortalConnector&apos;, &apos;false&apos;);

// dejongp configuration (&apos;HUB 2&apos;)
//channelMap.put(&apos;hubInstanceName&apos;, &apos;PHLISSA HUB 2&apos;);
//channelMap.put(&apos;hubHost&apos;, &apos;dejongp.us.saic.com&apos;);
//channelMap.put(&apos;hubInstanceEmailFromAddr&apos;, &apos;administrator@dejongp.us.saic.com&apos;);
//channelMap.put(&apos;hubInstanceWebSvcHost&apos;, &apos;dejongp.us.saic.com:8081&apos;);
//channelMap.put(&apos;enablePHIXPortalConnector&apos;, &apos;true&apos;);</string>
            </entry>
          </data>
        </step>
      </steps>
      <inboundTemplate encoding="base64"></inboundTemplate>
      <outboundTemplate encoding="base64"></outboundTemplate>
      <inboundProtocol>HL7V2</inboundProtocol>
      <outboundProtocol>HL7V2</outboundProtocol>
      <inboundProperties>
        <property name="convertLFtoCR">true</property>
        <property name="handleRepetitions">false</property>
        <property name="handleSubcomponents">false</property>
        <property name="stripNamespaces">true</property>
        <property name="useStrictParser">false</property>
        <property name="useStrictValidation">false</property>
      </inboundProperties>
      <outboundProperties>
        <property name="convertLFtoCR">true</property>
        <property name="handleRepetitions">false</property>
        <property name="handleSubcomponents">false</property>
        <property name="stripNamespaces">true</property>
        <property name="useStrictParser">false</property>
        <property name="useStrictValidation">false</property>
      </outboundProperties>
    </transformer>
    <filter>
      <rules/>
    </filter>
    <transportName>Channel Reader</transportName>
    <mode>SOURCE</mode>
    <enabled>true</enabled>
    <version>2.2.0.5828</version>
  </sourceConnector>
  <destinationConnectors>
    <connector>
      <name>Archive incoming message</name>
      <properties>
        <property name="DataType">File Writer</property>
        <property name="FTPAnonymous">1</property>
        <property name="binary">0</property>
        <property name="charsetEncoding">DEFAULT_ENCODING</property>
        <property name="errorOnExists">0</property>
        <property name="host">C:/phixdata/HL7_PROCESSED</property>
        <property name="outputAppend">0</property>
        <property name="outputPattern">${timestamp}_IN.txt</property>
        <property name="passive">1</property>
        <property name="password">anonymous</property>
        <property name="scheme">file</property>
        <property name="secure">1</property>
        <property name="template">${message.rawData}</property>
        <property name="temporary">0</property>
        <property name="timeout">10000</property>
        <property name="username">anonymous</property>
        <property name="validateConnections">1</property>
      </properties>
      <transformer>
        <steps>
          <step>
            <sequenceNumber>0</sequenceNumber>
            <name>Record timestamp for filename to channel map</name>
            <script>var ts = new java.lang.Long( java.lang.System.currentTimeMillis() );
channelMap.put(&apos;timestamp&apos;, ts.toString() );</script>
            <type>JavaScript</type>
            <data class="map">
              <entry>
                <string>Script</string>
                <string>var ts = new java.lang.Long( java.lang.System.currentTimeMillis() );
channelMap.put(&apos;timestamp&apos;, ts.toString() );</string>
              </entry>
            </data>
          </step>
        </steps>
        <inboundTemplate encoding="base64"></inboundTemplate>
        <outboundTemplate encoding="base64"></outboundTemplate>
        <inboundProtocol>HL7V2</inboundProtocol>
        <outboundProtocol>HL7V2</outboundProtocol>
        <inboundProperties>
          <property name="convertLFtoCR">true</property>
          <property name="handleRepetitions">false</property>
          <property name="handleSubcomponents">false</property>
          <property name="stripNamespaces">true</property>
          <property name="useStrictParser">false</property>
          <property name="useStrictValidation">false</property>
        </inboundProperties>
        <outboundProperties>
          <property name="convertLFtoCR">true</property>
          <property name="handleRepetitions">false</property>
          <property name="handleSubcomponents">false</property>
          <property name="stripNamespaces">true</property>
          <property name="useStrictParser">false</property>
          <property name="useStrictValidation">false</property>
        </outboundProperties>
      </transformer>
      <filter>
        <rules/>
      </filter>
      <transportName>File Writer</transportName>
      <mode>DESTINATION</mode>
      <enabled>true</enabled>
      <version>2.2.0.5828</version>
    </connector>
    <connector>
      <name>Call ComponentRoutingService</name>
      <properties>
        <property name="DataType">Web Service Sender</property>
        <property name="dispatcherAttachmentContents">&lt;list/&gt;</property>
        <property name="dispatcherAttachmentNames">&lt;list/&gt;</property>
        <property name="dispatcherAttachmentTypes">&lt;list/&gt;</property>
        <property name="dispatcherEnvelope">&lt;soapenv:Envelope  
  xmlns:q0=&quot;http://phlissa.cdc.gov/&quot;  
  xmlns:soapenv=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;  
  xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;  
  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&gt;  
  &lt;soapenv:Header&gt;  
  &lt;/soapenv:Header&gt;
  &lt;soapenv:Body&gt;  
    &lt;q0:getRoutingData&gt;
      &lt;msgType&gt;${msgType}&lt;/msgType&gt;
      &lt;triggerEvent&gt;${msgTriggerEvent}&lt;/triggerEvent&gt;
      &lt;hl7Version&gt;${msgHL7VersionID}&lt;/hl7Version&gt;
      &lt;sendingFacility&gt;${msgSendingFacilityID}&lt;/sendingFacility&gt;
      &lt;receivingFacility&gt;${msgReceivingFacilityID}&lt;/receivingFacility&gt;
    &lt;/q0:getRoutingData&gt;
  &lt;/soapenv:Body&gt;  
&lt;/soapenv:Envelope&gt;

</property>
        <property name="dispatcherOneWay">0</property>
        <property name="dispatcherOperation">getRoutingData</property>
        <property name="dispatcherPassword"></property>
        <property name="dispatcherPort">{http://phlissa.cdc.gov/}ComponentRoutingServicePort</property>
        <property name="dispatcherReplyChannelId">sink</property>
        <property name="dispatcherService">{http://phlissa.cdc.gov/}ComponentRoutingService</property>
        <property name="dispatcherSoapAction"></property>
        <property name="dispatcherUseAuthentication">0</property>
        <property name="dispatcherUseMtom">0</property>
        <property name="dispatcherUsername"></property>
        <property name="dispatcherWsdlCacheId"></property>
        <property name="dispatcherWsdlOperations">&lt;list&gt;
  &lt;string&gt;getRoutingData&lt;/string&gt;
&lt;/list&gt;</property>
        <property name="dispatcherWsdlUrl">http://localhost:8080/ComponentRoutingService/ComponentRoutingService?wsdl</property>
        <property name="host">localhost:8080/ComponentRoutingService/ComponentRoutingService?wsdl</property>
        <property name="queuePollInterval">200</property>
        <property name="reconnectMillisecs">10000</property>
        <property name="rotateQueue">0</property>
        <property name="usePersistentQueues">0</property>
      </properties>
      <transformer>
        <steps>
          <step>
            <sequenceNumber>0</sequenceNumber>
            <name>populate MSH sending facility based on RXA-11.4</name>
            <script>/*
try
{
  logger.info(&quot;populate MSH sending facility based on RXA-11.4&quot;);

  // 2.3.1 VXU V04: populate MSH-4 sending facility based on RXA-11.4
  if (msg[&apos;MSH&apos;][&apos;MSH.9&apos;][&apos;MSH.9.1&apos;].toString() == &quot;VXU&quot; &amp;&amp;
      msg[&apos;MSH&apos;][&apos;MSH.9&apos;][&apos;MSH.9.2&apos;].toString() == &quot;V04&quot; &amp;&amp;
      msg[&apos;MSH&apos;][&apos;MSH.12&apos;][&apos;MSH.12.1&apos;].toString() == &quot;2.3.1&quot;)
  {
    logger.info(&quot;2.3.1 VXU V04 message.  Examining RXA-11.4.&quot;);

    if (msg[&apos;RXA&apos;][0] != null &amp;&amp;
        undefined != msg[&apos;RXA&apos;][0][&apos;RXA.11&apos;][&apos;RXA.11.4&apos;])
    { 
      // if 11.4 contains subfields, grab only first subfield (11.4.1)
      var subfields = msg[&apos;RXA&apos;][0][&apos;RXA.11&apos;][&apos;RXA.11.4&apos;].toString().split(&quot;&amp;&quot;);      
      msg[&apos;MSH&apos;][&apos;MSH.4&apos;][&apos;MSH.4.1&apos;] = subfields[0];
      logger.info(&quot;Changing sending facility ID to &quot; + subfields[0] + &quot; based on RXA-11.4&quot;);
      channelMap.put(&apos;dynamicMsgSendingFacStatus&apos;, &apos;SET SENDING FAC TO &apos; + subfields[0] + &apos; BASED ON RXA-11.4&apos;);
    }
  }
}&#xd;catch(e)
{
  logger.error(&quot;Error in Call ComponentRoutingService MSH sending facility Transformer: &quot; + e.message);
  channelMap.put(&apos;componentErrors&apos;,  $(&apos;componentErrors&apos;) + &quot;Call ComponentRoutingService MSH sending facility Transformer:\n&quot; + e.message + &quot; |\n&quot;);
}
*/</script>
            <type>JavaScript</type>
            <data class="map">
              <entry>
                <string>Script</string>
                <string>/*
try
{
  logger.info(&quot;populate MSH sending facility based on RXA-11.4&quot;);

  // 2.3.1 VXU V04: populate MSH-4 sending facility based on RXA-11.4
  if (msg[&apos;MSH&apos;][&apos;MSH.9&apos;][&apos;MSH.9.1&apos;].toString() == &quot;VXU&quot; &amp;&amp;
      msg[&apos;MSH&apos;][&apos;MSH.9&apos;][&apos;MSH.9.2&apos;].toString() == &quot;V04&quot; &amp;&amp;
      msg[&apos;MSH&apos;][&apos;MSH.12&apos;][&apos;MSH.12.1&apos;].toString() == &quot;2.3.1&quot;)
  {
    logger.info(&quot;2.3.1 VXU V04 message.  Examining RXA-11.4.&quot;);

    if (msg[&apos;RXA&apos;][0] != null &amp;&amp;
        undefined != msg[&apos;RXA&apos;][0][&apos;RXA.11&apos;][&apos;RXA.11.4&apos;])
    { 
      // if 11.4 contains subfields, grab only first subfield (11.4.1)
      var subfields = msg[&apos;RXA&apos;][0][&apos;RXA.11&apos;][&apos;RXA.11.4&apos;].toString().split(&quot;&amp;&quot;);      
      msg[&apos;MSH&apos;][&apos;MSH.4&apos;][&apos;MSH.4.1&apos;] = subfields[0];
      logger.info(&quot;Changing sending facility ID to &quot; + subfields[0] + &quot; based on RXA-11.4&quot;);
      channelMap.put(&apos;dynamicMsgSendingFacStatus&apos;, &apos;SET SENDING FAC TO &apos; + subfields[0] + &apos; BASED ON RXA-11.4&apos;);
    }
  }
}&#xd;catch(e)
{
  logger.error(&quot;Error in Call ComponentRoutingService MSH sending facility Transformer: &quot; + e.message);
  channelMap.put(&apos;componentErrors&apos;,  $(&apos;componentErrors&apos;) + &quot;Call ComponentRoutingService MSH sending facility Transformer:\n&quot; + e.message + &quot; |\n&quot;);
}
*/</string>
              </entry>
            </data>
          </step>
          <step>
            <sequenceNumber>1</sequenceNumber>
            <name>dynamic routing of msg  based on PID-11.5 zip code</name>
            <script>/*
try
{
  logger.info(&quot;Dynamic routing of msg based on PID-11.5 zip code&quot;);

  // 2.3.1 VXU V04: route to Indiana Immunization Registry: 46001 to 47999
  if (msg[&apos;MSH&apos;][&apos;MSH.9&apos;][&apos;MSH.9.1&apos;].toString() == &quot;VXU&quot; &amp;&amp;
      msg[&apos;MSH&apos;][&apos;MSH.9&apos;][&apos;MSH.9.2&apos;].toString() == &quot;V04&quot; &amp;&amp;
      msg[&apos;MSH&apos;][&apos;MSH.12&apos;][&apos;MSH.12.1&apos;].toString() == &quot;2.3.1&quot;)
  {
    logger.info(&quot;2.3.1 VXU V04 message.  Examining zip code in PID-11.5&quot;);

    if (undefined != msg[&apos;PID&apos;][&apos;PID.11&apos;][&apos;PID.11.5&apos;])
    { 
      logger.info(&quot;PID-11.5: ZIP: &quot; + msg[&apos;PID&apos;][&apos;PID.11&apos;][&apos;PID.11.5&apos;].toString());
      var zip = parseInt(msg[&apos;PID&apos;][&apos;PID.11&apos;][&apos;PID.11.5&apos;].toString() );
     
      if (zip &gt;= 46001 &amp;&amp; zip &lt;= 47999)
      {
        logger.info(&quot;Changing receiving facility ID to Indiana Immunization Registry (IND_IMM_REG) based on zip&quot;);
        msg[&apos;MSH&apos;][&apos;MSH.6&apos;][&apos;MSH.6.1&apos;] = &quot;IND_IMM_REG&quot;;
        channelMap.put(&apos;dynamicMsgReceivingFacStatus&apos;, &apos;RE-ROUTED ZIP &apos; + msg[&apos;PID&apos;][&apos;PID.11&apos;][&apos;PID.11.5&apos;].toString() + &apos; TO INDIANA IMMUNIZATION REPOSITORY&apos;);
      }
      // TODO: else if ... insert new zip code range here for additional destinations
      else
      {
        logger.error(&quot;Error in Call ComponentRoutingService ZIP Transformer: No routing rule for 2.3.1 VXU V04 PID-11.5 zip code &quot; + msg[&apos;PID&apos;][&apos;PID.11&apos;][&apos;PID.11.5&apos;].toString() );
        channelMap.put(&apos;componentErrors&apos;,  $(&apos;componentErrors&apos;) + &quot;Error in Call ComponentRoutingService ZIP Transformer: No routing rule for 2.3.1 VXU V04 PID-11.5 zip code &quot; + msg[&apos;PID&apos;][&apos;PID.11&apos;][&apos;PID.11.5&apos;].toString() + &quot; |\n&quot;);
      }  
    }
  }
}&#xd;catch(e)
{
  logger.error(&quot;Error in Call ComponentRoutingService ZIP Transformer: &quot; + e.message);
  channelMap.put(&apos;componentErrors&apos;,  $(&apos;componentErrors&apos;) + &quot;Call ComponentRoutingService ZIP Transformer:\n&quot; + e.message + &quot; |\n&quot;);
}
*/</script>
            <type>JavaScript</type>
            <data class="map">
              <entry>
                <string>Script</string>
                <string>/*
try
{
  logger.info(&quot;Dynamic routing of msg based on PID-11.5 zip code&quot;);

  // 2.3.1 VXU V04: route to Indiana Immunization Registry: 46001 to 47999
  if (msg[&apos;MSH&apos;][&apos;MSH.9&apos;][&apos;MSH.9.1&apos;].toString() == &quot;VXU&quot; &amp;&amp;
      msg[&apos;MSH&apos;][&apos;MSH.9&apos;][&apos;MSH.9.2&apos;].toString() == &quot;V04&quot; &amp;&amp;
      msg[&apos;MSH&apos;][&apos;MSH.12&apos;][&apos;MSH.12.1&apos;].toString() == &quot;2.3.1&quot;)
  {
    logger.info(&quot;2.3.1 VXU V04 message.  Examining zip code in PID-11.5&quot;);

    if (undefined != msg[&apos;PID&apos;][&apos;PID.11&apos;][&apos;PID.11.5&apos;])
    { 
      logger.info(&quot;PID-11.5: ZIP: &quot; + msg[&apos;PID&apos;][&apos;PID.11&apos;][&apos;PID.11.5&apos;].toString());
      var zip = parseInt(msg[&apos;PID&apos;][&apos;PID.11&apos;][&apos;PID.11.5&apos;].toString() );
     
      if (zip &gt;= 46001 &amp;&amp; zip &lt;= 47999)
      {
        logger.info(&quot;Changing receiving facility ID to Indiana Immunization Registry (IND_IMM_REG) based on zip&quot;);
        msg[&apos;MSH&apos;][&apos;MSH.6&apos;][&apos;MSH.6.1&apos;] = &quot;IND_IMM_REG&quot;;
        channelMap.put(&apos;dynamicMsgReceivingFacStatus&apos;, &apos;RE-ROUTED ZIP &apos; + msg[&apos;PID&apos;][&apos;PID.11&apos;][&apos;PID.11.5&apos;].toString() + &apos; TO INDIANA IMMUNIZATION REPOSITORY&apos;);
      }
      // TODO: else if ... insert new zip code range here for additional destinations
      else
      {
        logger.error(&quot;Error in Call ComponentRoutingService ZIP Transformer: No routing rule for 2.3.1 VXU V04 PID-11.5 zip code &quot; + msg[&apos;PID&apos;][&apos;PID.11&apos;][&apos;PID.11.5&apos;].toString() );
        channelMap.put(&apos;componentErrors&apos;,  $(&apos;componentErrors&apos;) + &quot;Error in Call ComponentRoutingService ZIP Transformer: No routing rule for 2.3.1 VXU V04 PID-11.5 zip code &quot; + msg[&apos;PID&apos;][&apos;PID.11&apos;][&apos;PID.11.5&apos;].toString() + &quot; |\n&quot;);
      }  
    }
  }
}&#xd;catch(e)
{
  logger.error(&quot;Error in Call ComponentRoutingService ZIP Transformer: &quot; + e.message);
  channelMap.put(&apos;componentErrors&apos;,  $(&apos;componentErrors&apos;) + &quot;Call ComponentRoutingService ZIP Transformer:\n&quot; + e.message + &quot; |\n&quot;);
}
*/</string>
              </entry>
            </data>
          </step>
          <step>
            <sequenceNumber>2</sequenceNumber>
            <name>create variables for incoming MSH values</name>
            <script>try
{
  logger.info(&quot;Initializing component error log&quot;);
  channelMap.put(&apos;componentErrors&apos;, &quot;&quot;);

  channelMap.put(&apos;subscriptionName&apos;, &quot;&quot;);

  // extract msg type, trigger event, HL7 version, sending facility, and receiving facility from MSH
  SerializerFactory.getHL7Serializer().toXML(message);

  logger.info(&quot;Setting msgType=&quot; + msg[&apos;MSH&apos;][&apos;MSH.9&apos;][&apos;MSH.9.1&apos;].toString() );
  channelMap.put(&apos;msgType&apos;, msg[&apos;MSH&apos;][&apos;MSH.9&apos;][&apos;MSH.9.1&apos;].toString() );

  logger.info(&quot;Setting msgTriggerEvent=&quot; + msg[&apos;MSH&apos;][&apos;MSH.9&apos;][&apos;MSH.9.2&apos;].toString() );
  channelMap.put(&apos;msgTriggerEvent&apos;, msg[&apos;MSH&apos;][&apos;MSH.9&apos;][&apos;MSH.9.2&apos;].toString() );

  logger.info(&quot;Setting msgHL7VersionID=&quot; + msg[&apos;MSH&apos;][&apos;MSH.12&apos;][&apos;MSH.12.1&apos;].toString() );
  channelMap.put(&apos;msgHL7VersionID&apos;, msg[&apos;MSH&apos;][&apos;MSH.12&apos;][&apos;MSH.12.1&apos;].toString() );

  logger.info(&quot;Setting msgSendingFacilityID=&quot; + msg[&apos;MSH&apos;][&apos;MSH.4&apos;][&apos;MSH.4.1&apos;].toString() );
  channelMap.put(&apos;msgSendingFacilityID&apos;, msg[&apos;MSH&apos;][&apos;MSH.4&apos;][&apos;MSH.4.1&apos;].toString() );

  logger.info(&quot;Setting msgReceivingFacilityID=&quot; + msg[&apos;MSH&apos;][&apos;MSH.6&apos;][&apos;MSH.6.1&apos;].toString() );
  channelMap.put(&apos;msgReceivingFacilityID&apos;, msg[&apos;MSH&apos;][&apos;MSH.6&apos;][&apos;MSH.6.1&apos;].toString() );

  logger.info(&quot;Setting msgDateTime=&quot; + msg[&apos;MSH&apos;][&apos;MSH.7&apos;][&apos;MSH.7.1&apos;].toString() );
  channelMap.put(&apos;msgDateTime&apos;, msg[&apos;MSH&apos;][&apos;MSH.7&apos;][&apos;MSH.7.1&apos;].toString() );

  logger.info(&quot;Setting msgCtrlID=&quot; +  msg[&apos;MSH&apos;][&apos;MSH.10&apos;][&apos;MSH.10.1&apos;].toString() );
  channelMap.put(&apos;msgCtrlID&apos;, msg[&apos;MSH&apos;][&apos;MSH.10&apos;][&apos;MSH.10.1&apos;].toString() );

  if (&quot;&quot; == $(&apos;dynamicMsgSendingFacStatus&apos;))
  {
    channelMap.put(&apos;dynamicMsgSendingFacStatus&apos;, &apos;BYPASSED&apos;);
  }

  if (&quot;&quot; == $(&apos;dynamicMsgReceivingFacStatus&apos;))
  {
    channelMap.put(&apos;dynamicMsgReceivingFacStatus&apos;, &apos;BYPASSED&apos;);
  }

}&#xd;catch(e)
{
  logger.error(&quot;Error in Call ComponentRoutingService MSH Transformer: &quot; + e.message);
  channelMap.put(&apos;componentErrors&apos;,  $(&apos;componentErrors&apos;) + &quot;Call ComponentRoutingService MSH Transformer:\n&quot; + e.message + &quot; |\n&quot;);
}</script>
            <type>JavaScript</type>
            <data class="map">
              <entry>
                <string>Script</string>
                <string>try
{
  logger.info(&quot;Initializing component error log&quot;);
  channelMap.put(&apos;componentErrors&apos;, &quot;&quot;);

  channelMap.put(&apos;subscriptionName&apos;, &quot;&quot;);

  // extract msg type, trigger event, HL7 version, sending facility, and receiving facility from MSH
  SerializerFactory.getHL7Serializer().toXML(message);

  logger.info(&quot;Setting msgType=&quot; + msg[&apos;MSH&apos;][&apos;MSH.9&apos;][&apos;MSH.9.1&apos;].toString() );
  channelMap.put(&apos;msgType&apos;, msg[&apos;MSH&apos;][&apos;MSH.9&apos;][&apos;MSH.9.1&apos;].toString() );

  logger.info(&quot;Setting msgTriggerEvent=&quot; + msg[&apos;MSH&apos;][&apos;MSH.9&apos;][&apos;MSH.9.2&apos;].toString() );
  channelMap.put(&apos;msgTriggerEvent&apos;, msg[&apos;MSH&apos;][&apos;MSH.9&apos;][&apos;MSH.9.2&apos;].toString() );

  logger.info(&quot;Setting msgHL7VersionID=&quot; + msg[&apos;MSH&apos;][&apos;MSH.12&apos;][&apos;MSH.12.1&apos;].toString() );
  channelMap.put(&apos;msgHL7VersionID&apos;, msg[&apos;MSH&apos;][&apos;MSH.12&apos;][&apos;MSH.12.1&apos;].toString() );

  logger.info(&quot;Setting msgSendingFacilityID=&quot; + msg[&apos;MSH&apos;][&apos;MSH.4&apos;][&apos;MSH.4.1&apos;].toString() );
  channelMap.put(&apos;msgSendingFacilityID&apos;, msg[&apos;MSH&apos;][&apos;MSH.4&apos;][&apos;MSH.4.1&apos;].toString() );

  logger.info(&quot;Setting msgReceivingFacilityID=&quot; + msg[&apos;MSH&apos;][&apos;MSH.6&apos;][&apos;MSH.6.1&apos;].toString() );
  channelMap.put(&apos;msgReceivingFacilityID&apos;, msg[&apos;MSH&apos;][&apos;MSH.6&apos;][&apos;MSH.6.1&apos;].toString() );

  logger.info(&quot;Setting msgDateTime=&quot; + msg[&apos;MSH&apos;][&apos;MSH.7&apos;][&apos;MSH.7.1&apos;].toString() );
  channelMap.put(&apos;msgDateTime&apos;, msg[&apos;MSH&apos;][&apos;MSH.7&apos;][&apos;MSH.7.1&apos;].toString() );

  logger.info(&quot;Setting msgCtrlID=&quot; +  msg[&apos;MSH&apos;][&apos;MSH.10&apos;][&apos;MSH.10.1&apos;].toString() );
  channelMap.put(&apos;msgCtrlID&apos;, msg[&apos;MSH&apos;][&apos;MSH.10&apos;][&apos;MSH.10.1&apos;].toString() );

  if (&quot;&quot; == $(&apos;dynamicMsgSendingFacStatus&apos;))
  {
    channelMap.put(&apos;dynamicMsgSendingFacStatus&apos;, &apos;BYPASSED&apos;);
  }

  if (&quot;&quot; == $(&apos;dynamicMsgReceivingFacStatus&apos;))
  {
    channelMap.put(&apos;dynamicMsgReceivingFacStatus&apos;, &apos;BYPASSED&apos;);
  }

}&#xd;catch(e)
{
  logger.error(&quot;Error in Call ComponentRoutingService MSH Transformer: &quot; + e.message);
  channelMap.put(&apos;componentErrors&apos;,  $(&apos;componentErrors&apos;) + &quot;Call ComponentRoutingService MSH Transformer:\n&quot; + e.message + &quot; |\n&quot;);
}</string>
              </entry>
            </data>
          </step>
        </steps>
        <inboundTemplate encoding="base64"></inboundTemplate>
        <outboundTemplate encoding="base64"></outboundTemplate>
        <inboundProtocol>HL7V2</inboundProtocol>
        <outboundProtocol>HL7V2</outboundProtocol>
        <inboundProperties>
          <property name="convertLFtoCR">true</property>
          <property name="handleRepetitions">false</property>
          <property name="handleSubcomponents">false</property>
          <property name="stripNamespaces">true</property>
          <property name="useStrictParser">false</property>
          <property name="useStrictValidation">false</property>
        </inboundProperties>
        <outboundProperties>
          <property name="convertLFtoCR">true</property>
          <property name="handleRepetitions">false</property>
          <property name="handleSubcomponents">false</property>
          <property name="stripNamespaces">true</property>
          <property name="useStrictParser">false</property>
          <property name="useStrictValidation">false</property>
        </outboundProperties>
      </transformer>
      <filter>
        <rules/>
      </filter>
      <transportName>Web Service Sender</transportName>
      <mode>DESTINATION</mode>
      <enabled>true</enabled>
      <version>2.2.0.5828</version>
    </connector>
    <connector>
      <name>Process ComponentRoutingService Response</name>
      <properties>
        <property name="DataType">Channel Writer</property>
        <property name="host">sink</property>
        <property name="synchronised">0</property>
        <property name="template">${message.encodedData}</property>
      </properties>
      <transformer>
        <steps>
          <step>
            <sequenceNumber>0</sequenceNumber>
            <name>process web service response</name>
            <script>try
{
  // process the response to the ComponentRoutingService invocation, storing data to the channelMap
  var resp = new XML(responseMap.get(&apos;Call ComponentRoutingService&apos;).getMessage());

  logger.info(&quot;Processing ComponentRoutingService web svc response&quot;);
  logger.info(resp);

  // If routingData is not present in response XML, a SOAP fault was likely returned from service call.  Record the 
  // response to the componentErrors variable and don&apos;t attempt to process component configuration items.
  if (undefined == resp..*::Body.*::getRoutingDataResponse.*::[&apos;routingData&apos;])
  {
    logger.error(&quot;No routingData element found in ComponentRoutingService response. Recording response to componentErrors variable: &quot; + resp);
    channelMap.put(&apos;componentErrors&apos;,  $(&apos;componentErrors&apos;) + &quot;ComponentRoutingService:\n&quot; + resp + &quot; |\n&quot;);
  }
  else
  {
    var xml = new XML(resp..*::Body.*::getRoutingDataResponse.*::[&apos;routingData&apos;].toString());

    logger.info(&quot;structural validation=&quot; + xml[&apos;structuralValidation&apos;]);
    logger.info(&quot;structuralValidationRegexpFilters=&quot; + xml[&apos;structuralValidationRegexpFilters&apos;]);
    logger.info(&quot;vocabTranslation=&quot; + xml[&apos;vocabTranslation&apos;]);
    logger.info(&quot;codeValidation=&quot; + xml[&apos;codeValidation&apos;]);
    logger.info(&quot;subscription=&quot; + xml[&apos;subscription&apos;]);
    logger.info(&quot;anonymization=&quot; + xml[&apos;anonymization&apos;]);
    logger.info(&quot;addSFTSegment=&quot; + xml[&apos;addSFTSegment&apos;]);
    logger.info(&quot;addSPMSegment=&quot; + xml[&apos;addSPMSegment&apos;]);
    logger.info(&quot;translateToVersion=&quot; + xml[&apos;translateToVersion&apos;]);
    logger.info(&quot;vocabTranslationMSSProfile=&quot; + xml[&apos;vocabTranslationMSSProfile&apos;]);
    logger.info(&quot;codeValidationMSSProfile=&quot; + xml[&apos;codeValidationMSSProfile&apos;]);
    logger.info(&quot;customProfileName=&quot; + xml[&apos;customProfileName&apos;]);
    logger.info(&quot;sendingFacilityDirectEmailAddress=&quot; + xml[&apos;sendingFacilityDirectEmailAddress&apos;]);
    logger.info(&quot;sendingFacilityNotificationEmail=&quot; + xml[&apos;sendingFacilityNotificationEmail&apos;]);
    logger.info(&quot;sendingFacilityErrorNotificationEmail=&quot; + xml[&apos;sendingFacilityErrorNotificationEmail&apos;]);
    logger.info(&quot;sendingFacilityWebSvcHost=&quot; + xml[&apos;sendingFacilityWebSvcHost&apos;]);
    logger.info(&quot;sendingFacilityXportType=&quot; + xml[&apos;sendingFacilityXportType&apos;]);
    logger.info(&quot;sendingFacilityHubHost=&quot; + xml[&apos;sendingFacilityHubHost&apos;]);
    logger.info(&quot;receivingFacilityDirectEmailAddress=&quot; + xml[&apos;receivingFacilityDirectEmailAddress&apos;]);
    logger.info(&quot;receivingFacilityWebSvcHost=&quot; + xml[&apos;receivingFacilityWebSvcHost&apos;]);
    logger.info(&quot;receivingFacilityXportType=&quot; + xml[&apos;receivingFacilityXportType&apos;]);
    logger.info(&quot;receivingFacilityHubHost=&quot; + xml[&apos;receivingFacilityHubHost&apos;]);

    channelMap.put(&apos;structuralValidation&apos;, xml[&apos;structuralValidation&apos;]);
    channelMap.put(&apos;structuralValidationRegexpFilters&apos;, xml[&apos;structuralValidationRegexpFilters&apos;]);
    channelMap.put(&apos;vocabTranslation&apos;, xml[&apos;vocabTranslation&apos;]);
    channelMap.put(&apos;codeValidation&apos;, xml[&apos;codeValidation&apos;]);
    channelMap.put(&apos;subscription&apos;, xml[&apos;subscription&apos;]);
    channelMap.put(&apos;anonymization&apos;, xml[&apos;anonymization&apos;]);
    channelMap.put(&apos;addSFTSegment&apos;, xml[&apos;addSFTSegment&apos;]);
    channelMap.put(&apos;addSPMSegment&apos;, xml[&apos;addSPMSegment&apos;]);
    channelMap.put(&apos;translateToVersion&apos;, xml[&apos;translateToVersion&apos;]);
    channelMap.put(&apos;vocabTranslationMSSProfile&apos;, xml[&apos;vocabTranslationMSSProfile&apos;]);
    channelMap.put(&apos;codeValidationMSSProfile&apos;, xml[&apos;codeValidationMSSProfile&apos;]);
    channelMap.put(&apos;customProfileName&apos;, xml[&apos;customProfileName&apos;]);
    channelMap.put(&apos;sendingFacilityDirectEmailAddress&apos;, xml[&apos;sendingFacilityDirectEmailAddress&apos;]);
    channelMap.put(&apos;sendingFacilityNotificationEmail&apos;, xml[&apos;sendingFacilityNotificationEmail&apos;]);

    if (&quot;&quot; == xml[&apos;sendingFacilityErrorNotificationEmail&apos;] )
    {
      channelMap.put(&apos;sendingFacilityErrorNotificationEmail&apos;, &apos;NONE&apos;);
    }
    else
    {
      channelMap.put(&apos;sendingFacilityErrorNotificationEmail&apos;, xml[&apos;sendingFacilityErrorNotificationEmail&apos;]);
    }
    
    channelMap.put(&apos;sendingFacilityWebSvcHost&apos;, xml[&apos;sendingFacilityWebSvcHost&apos;]);
    channelMap.put(&apos;sendingFacilityXportType&apos;, xml[&apos;sendingFacilityXportType&apos;]);
    channelMap.put(&apos;sendingFacilityHubHost&apos;, xml[&apos;sendingFacilityHubHost&apos;]);
    channelMap.put(&apos;receivingFacilityDirectEmailAddress&apos;, xml[&apos;receivingFacilityDirectEmailAddress&apos;]);
    channelMap.put(&apos;receivingFacilityWebSvcHost&apos;, xml[&apos;receivingFacilityWebSvcHost&apos;]);
    channelMap.put(&apos;receivingFacilityXportType&apos;, xml[&apos;receivingFacilityXportType&apos;]);
    channelMap.put(&apos;receivingFacilityHubHost&apos;, xml[&apos;receivingFacilityHubHost&apos;]);
  }
}
catch(e)
{
  logger.error(&quot;Error in Process ComponentRoutingService Response Transformer: &quot; + e.message);
  channelMap.put(&apos;componentErrors&apos;,  $(&apos;componentErrors&apos;) + &quot;Process ComponentRoutingService Response Transformer:\n&quot; + e.message + &quot; |\n&quot;);
}</script>
            <type>JavaScript</type>
            <data class="map">
              <entry>
                <string>Script</string>
                <string>try
{
  // process the response to the ComponentRoutingService invocation, storing data to the channelMap
  var resp = new XML(responseMap.get(&apos;Call ComponentRoutingService&apos;).getMessage());

  logger.info(&quot;Processing ComponentRoutingService web svc response&quot;);
  logger.info(resp);

  // If routingData is not present in response XML, a SOAP fault was likely returned from service call.  Record the 
  // response to the componentErrors variable and don&apos;t attempt to process component configuration items.
  if (undefined == resp..*::Body.*::getRoutingDataResponse.*::[&apos;routingData&apos;])
  {
    logger.error(&quot;No routingData element found in ComponentRoutingService response. Recording response to componentErrors variable: &quot; + resp);
    channelMap.put(&apos;componentErrors&apos;,  $(&apos;componentErrors&apos;) + &quot;ComponentRoutingService:\n&quot; + resp + &quot; |\n&quot;);
  }
  else
  {
    var xml = new XML(resp..*::Body.*::getRoutingDataResponse.*::[&apos;routingData&apos;].toString());

    logger.info(&quot;structural validation=&quot; + xml[&apos;structuralValidation&apos;]);
    logger.info(&quot;structuralValidationRegexpFilters=&quot; + xml[&apos;structuralValidationRegexpFilters&apos;]);
    logger.info(&quot;vocabTranslation=&quot; + xml[&apos;vocabTranslation&apos;]);
    logger.info(&quot;codeValidation=&quot; + xml[&apos;codeValidation&apos;]);
    logger.info(&quot;subscription=&quot; + xml[&apos;subscription&apos;]);
    logger.info(&quot;anonymization=&quot; + xml[&apos;anonymization&apos;]);
    logger.info(&quot;addSFTSegment=&quot; + xml[&apos;addSFTSegment&apos;]);
    logger.info(&quot;addSPMSegment=&quot; + xml[&apos;addSPMSegment&apos;]);
    logger.info(&quot;translateToVersion=&quot; + xml[&apos;translateToVersion&apos;]);
    logger.info(&quot;vocabTranslationMSSProfile=&quot; + xml[&apos;vocabTranslationMSSProfile&apos;]);
    logger.info(&quot;codeValidationMSSProfile=&quot; + xml[&apos;codeValidationMSSProfile&apos;]);
    logger.info(&quot;customProfileName=&quot; + xml[&apos;customProfileName&apos;]);
    logger.info(&quot;sendingFacilityDirectEmailAddress=&quot; + xml[&apos;sendingFacilityDirectEmailAddress&apos;]);
    logger.info(&quot;sendingFacilityNotificationEmail=&quot; + xml[&apos;sendingFacilityNotificationEmail&apos;]);
    logger.info(&quot;sendingFacilityErrorNotificationEmail=&quot; + xml[&apos;sendingFacilityErrorNotificationEmail&apos;]);
    logger.info(&quot;sendingFacilityWebSvcHost=&quot; + xml[&apos;sendingFacilityWebSvcHost&apos;]);
    logger.info(&quot;sendingFacilityXportType=&quot; + xml[&apos;sendingFacilityXportType&apos;]);
    logger.info(&quot;sendingFacilityHubHost=&quot; + xml[&apos;sendingFacilityHubHost&apos;]);
    logger.info(&quot;receivingFacilityDirectEmailAddress=&quot; + xml[&apos;receivingFacilityDirectEmailAddress&apos;]);
    logger.info(&quot;receivingFacilityWebSvcHost=&quot; + xml[&apos;receivingFacilityWebSvcHost&apos;]);
    logger.info(&quot;receivingFacilityXportType=&quot; + xml[&apos;receivingFacilityXportType&apos;]);
    logger.info(&quot;receivingFacilityHubHost=&quot; + xml[&apos;receivingFacilityHubHost&apos;]);

    channelMap.put(&apos;structuralValidation&apos;, xml[&apos;structuralValidation&apos;]);
    channelMap.put(&apos;structuralValidationRegexpFilters&apos;, xml[&apos;structuralValidationRegexpFilters&apos;]);
    channelMap.put(&apos;vocabTranslation&apos;, xml[&apos;vocabTranslation&apos;]);
    channelMap.put(&apos;codeValidation&apos;, xml[&apos;codeValidation&apos;]);
    channelMap.put(&apos;subscription&apos;, xml[&apos;subscription&apos;]);
    channelMap.put(&apos;anonymization&apos;, xml[&apos;anonymization&apos;]);
    channelMap.put(&apos;addSFTSegment&apos;, xml[&apos;addSFTSegment&apos;]);
    channelMap.put(&apos;addSPMSegment&apos;, xml[&apos;addSPMSegment&apos;]);
    channelMap.put(&apos;translateToVersion&apos;, xml[&apos;translateToVersion&apos;]);
    channelMap.put(&apos;vocabTranslationMSSProfile&apos;, xml[&apos;vocabTranslationMSSProfile&apos;]);
    channelMap.put(&apos;codeValidationMSSProfile&apos;, xml[&apos;codeValidationMSSProfile&apos;]);
    channelMap.put(&apos;customProfileName&apos;, xml[&apos;customProfileName&apos;]);
    channelMap.put(&apos;sendingFacilityDirectEmailAddress&apos;, xml[&apos;sendingFacilityDirectEmailAddress&apos;]);
    channelMap.put(&apos;sendingFacilityNotificationEmail&apos;, xml[&apos;sendingFacilityNotificationEmail&apos;]);

    if (&quot;&quot; == xml[&apos;sendingFacilityErrorNotificationEmail&apos;] )
    {
      channelMap.put(&apos;sendingFacilityErrorNotificationEmail&apos;, &apos;NONE&apos;);
    }
    else
    {
      channelMap.put(&apos;sendingFacilityErrorNotificationEmail&apos;, xml[&apos;sendingFacilityErrorNotificationEmail&apos;]);
    }
    
    channelMap.put(&apos;sendingFacilityWebSvcHost&apos;, xml[&apos;sendingFacilityWebSvcHost&apos;]);
    channelMap.put(&apos;sendingFacilityXportType&apos;, xml[&apos;sendingFacilityXportType&apos;]);
    channelMap.put(&apos;sendingFacilityHubHost&apos;, xml[&apos;sendingFacilityHubHost&apos;]);
    channelMap.put(&apos;receivingFacilityDirectEmailAddress&apos;, xml[&apos;receivingFacilityDirectEmailAddress&apos;]);
    channelMap.put(&apos;receivingFacilityWebSvcHost&apos;, xml[&apos;receivingFacilityWebSvcHost&apos;]);
    channelMap.put(&apos;receivingFacilityXportType&apos;, xml[&apos;receivingFacilityXportType&apos;]);
    channelMap.put(&apos;receivingFacilityHubHost&apos;, xml[&apos;receivingFacilityHubHost&apos;]);
  }
}
catch(e)
{
  logger.error(&quot;Error in Process ComponentRoutingService Response Transformer: &quot; + e.message);
  channelMap.put(&apos;componentErrors&apos;,  $(&apos;componentErrors&apos;) + &quot;Process ComponentRoutingService Response Transformer:\n&quot; + e.message + &quot; |\n&quot;);
}</string>
              </entry>
            </data>
          </step>
        </steps>
        <inboundTemplate encoding="base64"></inboundTemplate>
        <outboundTemplate encoding="base64"></outboundTemplate>
        <inboundProtocol>HL7V2</inboundProtocol>
        <outboundProtocol>HL7V2</outboundProtocol>
        <inboundProperties>
          <property name="convertLFtoCR">true</property>
          <property name="handleRepetitions">false</property>
          <property name="handleSubcomponents">false</property>
          <property name="stripNamespaces">true</property>
          <property name="useStrictParser">false</property>
          <property name="useStrictValidation">false</property>
        </inboundProperties>
        <outboundProperties>
          <property name="convertLFtoCR">true</property>
          <property name="handleRepetitions">false</property>
          <property name="handleSubcomponents">false</property>
          <property name="stripNamespaces">true</property>
          <property name="useStrictParser">false</property>
          <property name="useStrictValidation">false</property>
        </outboundProperties>
      </transformer>
      <filter>
        <rules/>
      </filter>
      <transportName>Channel Writer</transportName>
      <mode>DESTINATION</mode>
      <enabled>true</enabled>
      <version>2.2.0.5828</version>
    </connector>
    <connector>
      <name>Call StructuralValidationService</name>
      <properties>
        <property name="DataType">Web Service Sender</property>
        <property name="dispatcherAttachmentContents">&lt;list/&gt;</property>
        <property name="dispatcherAttachmentNames">&lt;list/&gt;</property>
        <property name="dispatcherAttachmentTypes">&lt;list/&gt;</property>
        <property name="dispatcherEnvelope">&lt;soapenv:Envelope xmlns:q0=&quot;http://phlissa.cdc.gov/&quot; xmlns:soapenv=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;  
  xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;  
  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&gt;  
  &lt;soapenv:Header /&gt;
  &lt;soapenv:Body&gt;  
    &lt;q0:validateWithFiltering&gt;
      &lt;hl7Message&gt;&lt;![CDATA[${message.encodedData}]]&gt;&lt;/hl7Message&gt;
      &lt;regexpFilters&gt;&lt;![CDATA[${structuralValidationRegexpFilters}]]&gt;&lt;/regexpFilters&gt;
      &lt;customProfileName&gt;&lt;![CDATA[${customProfileName}]]&gt;&lt;/customProfileName&gt;
    &lt;/q0:validateWithFiltering&gt;
  &lt;/soapenv:Body&gt;  
&lt;/soapenv:Envelope&gt; 
</property>
        <property name="dispatcherOneWay">0</property>
        <property name="dispatcherOperation">validateWithFiltering</property>
        <property name="dispatcherPassword"></property>
        <property name="dispatcherPort">{http://phlissa.cdc.gov/}StructuralValidationServicePort</property>
        <property name="dispatcherReplyChannelId">sink</property>
        <property name="dispatcherService">{http://phlissa.cdc.gov/}StructuralValidationService</property>
        <property name="dispatcherSoapAction"></property>
        <property name="dispatcherUseAuthentication">0</property>
        <property name="dispatcherUseMtom">0</property>
        <property name="dispatcherUsername"></property>
        <property name="dispatcherWsdlCacheId"></property>
        <property name="dispatcherWsdlOperations">&lt;list&gt;
  &lt;string&gt;validate&lt;/string&gt;
  &lt;string&gt;validateErrorArray&lt;/string&gt;
  &lt;string&gt;validateErrorArrayWithFiltering&lt;/string&gt;
  &lt;string&gt;validateWithFiltering&lt;/string&gt;
&lt;/list&gt;</property>
        <property name="dispatcherWsdlUrl">http://localhost:8080/StructuralValidationService/StructuralValidationService?wsdl</property>
        <property name="host">localhost:8080/StructuralValidationService/StructuralValidationService?wsdl</property>
        <property name="queuePollInterval">200</property>
        <property name="reconnectMillisecs">10000</property>
        <property name="rotateQueue">0</property>
        <property name="usePersistentQueues">0</property>
      </properties>
      <transformer>
        <steps>
          <step>
            <sequenceNumber>0</sequenceNumber>
            <name>Add msg structure if missing</name>
            <script>// If MSH.9.3/message structure is missing, generate it based on MSH.9.1 and MSH.9.2 to avoid HAPI validation error.

try
{
  if ( ((undefined == msg[&apos;MSH&apos;][&apos;MSH.9&apos;][&apos;MSH.9.3&apos;]) || (msg[&apos;MSH&apos;][&apos;MSH.9&apos;][&apos;MSH.9.3&apos;] == &apos;&apos;)) &amp;&amp;
       undefined != msg[&apos;MSH&apos;][&apos;MSH.9&apos;][&apos;MSH.9.1&apos;] &amp;&amp;
       msg[&apos;MSH&apos;][&apos;MSH.9&apos;][&apos;MSH.9.1&apos;].toString().length &gt; 0 &amp;&amp;
       undefined != msg[&apos;MSH&apos;][&apos;MSH.9&apos;][&apos;MSH.9.2&apos;] &amp;&amp;
       msg[&apos;MSH&apos;][&apos;MSH.9&apos;][&apos;MSH.9.2&apos;].toString().length &gt; 0 )
  {
    logger.info(&quot;MSH-9.3 (msg structure) field not present. Generating new value from MSH-9.2 and MSH-9.3.&quot;);
    msg[&apos;MSH&apos;][&apos;MSH.9&apos;][&apos;MSH.9.3&apos;] = msg[&apos;MSH&apos;][&apos;MSH.9&apos;][&apos;MSH.9.1&apos;].toString() + &quot;_&quot; + msg[&apos;MSH&apos;][&apos;MSH.9&apos;][&apos;MSH.9.2&apos;].toString();
    logger.info(&quot;MSH-9.3 is now: &quot; + msg[&apos;MSH&apos;][&apos;MSH.9&apos;][&apos;MSH.9.3&apos;].toString() );
  }

}&#xd;catch(e)
{
  logger.error(&quot;Error in Call StructuralValidationService Transformer: &quot; + e.message);
  channelMap.put(&apos;componentErrors&apos;,  $(&apos;componentErrors&apos;) + &quot;Call StructuralValidationService Transformer:\n&quot; + e.message + &quot; |\n&quot;);
}</script>
            <type>JavaScript</type>
            <data class="map">
              <entry>
                <string>Script</string>
                <string>// If MSH.9.3/message structure is missing, generate it based on MSH.9.1 and MSH.9.2 to avoid HAPI validation error.

try
{
  if ( ((undefined == msg[&apos;MSH&apos;][&apos;MSH.9&apos;][&apos;MSH.9.3&apos;]) || (msg[&apos;MSH&apos;][&apos;MSH.9&apos;][&apos;MSH.9.3&apos;] == &apos;&apos;)) &amp;&amp;
       undefined != msg[&apos;MSH&apos;][&apos;MSH.9&apos;][&apos;MSH.9.1&apos;] &amp;&amp;
       msg[&apos;MSH&apos;][&apos;MSH.9&apos;][&apos;MSH.9.1&apos;].toString().length &gt; 0 &amp;&amp;
       undefined != msg[&apos;MSH&apos;][&apos;MSH.9&apos;][&apos;MSH.9.2&apos;] &amp;&amp;
       msg[&apos;MSH&apos;][&apos;MSH.9&apos;][&apos;MSH.9.2&apos;].toString().length &gt; 0 )
  {
    logger.info(&quot;MSH-9.3 (msg structure) field not present. Generating new value from MSH-9.2 and MSH-9.3.&quot;);
    msg[&apos;MSH&apos;][&apos;MSH.9&apos;][&apos;MSH.9.3&apos;] = msg[&apos;MSH&apos;][&apos;MSH.9&apos;][&apos;MSH.9.1&apos;].toString() + &quot;_&quot; + msg[&apos;MSH&apos;][&apos;MSH.9&apos;][&apos;MSH.9.2&apos;].toString();
    logger.info(&quot;MSH-9.3 is now: &quot; + msg[&apos;MSH&apos;][&apos;MSH.9&apos;][&apos;MSH.9.3&apos;].toString() );
  }

}&#xd;catch(e)
{
  logger.error(&quot;Error in Call StructuralValidationService Transformer: &quot; + e.message);
  channelMap.put(&apos;componentErrors&apos;,  $(&apos;componentErrors&apos;) + &quot;Call StructuralValidationService Transformer:\n&quot; + e.message + &quot; |\n&quot;);
}</string>
              </entry>
            </data>
          </step>
        </steps>
        <inboundTemplate encoding="base64"></inboundTemplate>
        <outboundTemplate encoding="base64"></outboundTemplate>
        <inboundProtocol>HL7V2</inboundProtocol>
        <outboundProtocol>HL7V2</outboundProtocol>
        <inboundProperties>
          <property name="convertLFtoCR">true</property>
          <property name="handleRepetitions">false</property>
          <property name="handleSubcomponents">false</property>
          <property name="stripNamespaces">true</property>
          <property name="useStrictParser">false</property>
          <property name="useStrictValidation">false</property>
        </inboundProperties>
        <outboundProperties>
          <property name="convertLFtoCR">true</property>
          <property name="handleRepetitions">false</property>
          <property name="handleSubcomponents">false</property>
          <property name="stripNamespaces">true</property>
          <property name="useStrictParser">false</property>
          <property name="useStrictValidation">false</property>
        </outboundProperties>
      </transformer>
      <filter>
        <rules>
          <rule>
            <sequenceNumber>0</sequenceNumber>
            <name>Filter call to StructuralValidationService based on ComponentRoutingService configuration</name>
            <data class="map">
              <entry>
                <string>Script</string>
                <string>var retval = false;


if ($(&apos;structuralValidation&apos;) != &apos;true&apos;)
{
  logger.info(&quot;Bypassing StructuralValidationService call based on component routing configuration&quot;);
}
else if ($(&apos;componentErrors&apos;).length() &gt; 0)
{
  logger.info(&quot;Bypassing StructuralValidationService call because of prior errors: &quot; + $(&apos;componentErrors&apos;));
}
else
{
  logger.info(&quot;Calling StructuralValidationService&quot;);
  retval = true;
}

if (retval)
{
  channelMap.put(&apos;strucutralValidationCallStatus&apos;, &apos;CALLED&apos;);
}
else
{
  channelMap.put(&apos;strucutralValidationCallStatus&apos;, &apos;BYPASSED&apos;);
}

return retval;</string>
              </entry>
            </data>
            <type>JavaScript</type>
            <script>var retval = false;


if ($(&apos;structuralValidation&apos;) != &apos;true&apos;)
{
  logger.info(&quot;Bypassing StructuralValidationService call based on component routing configuration&quot;);
}
else if ($(&apos;componentErrors&apos;).length() &gt; 0)
{
  logger.info(&quot;Bypassing StructuralValidationService call because of prior errors: &quot; + $(&apos;componentErrors&apos;));
}
else
{
  logger.info(&quot;Calling StructuralValidationService&quot;);
  retval = true;
}

if (retval)
{
  channelMap.put(&apos;strucutralValidationCallStatus&apos;, &apos;CALLED&apos;);
}
else
{
  channelMap.put(&apos;strucutralValidationCallStatus&apos;, &apos;BYPASSED&apos;);
}

return retval;</script>
            <operator>NONE</operator>
          </rule>
        </rules>
      </filter>
      <transportName>Web Service Sender</transportName>
      <mode>DESTINATION</mode>
      <enabled>false</enabled>
      <version>2.2.0.5828</version>
    </connector>
    <connector>
      <name>Process StructuralValidationService Response</name>
      <properties>
        <property name="DataType">Channel Writer</property>
        <property name="host">sink</property>
        <property name="synchronised">0</property>
        <property name="template">${message.encodedData}</property>
      </properties>
      <transformer>
        <steps>
          <step>
            <sequenceNumber>0</sequenceNumber>
            <name>process StructuralValidationService web service response</name>
            <script>try
{
  logger.info(&quot;Processing StructuralValidationService web svc response&quot;);

  var resp = new XML(responseMap.get(&apos;Call StructuralValidationService&apos;).getMessage());
  logger.info(resp);


  // If validationErrors is not present in response XML, a SOAP fault was likely returned from service call.  Record the 
  // response to the componentErrors variable and don&apos;t attempt to parse the validation errors.
  if (undefined == resp..*::Body..*::validateWithFilteringResponse.*::[&apos;validationErrors&apos;])
  {
    logger.error(&quot;No validationErrors element found in StructuralValidationService response. Recording response to componentErrors variable: &quot; + resp);
    channelMap.put(&apos;componentErrors&apos;,  $(&apos;componentErrors&apos;) + &quot;StructuralValidationService:\n&quot; + resp + &quot; |\n&quot;);
  }
  else
  {
    var xml = new XML(resp..*::Body..*::[&apos;validateWithFilteringResponse&apos;].toString() );
    var validationErrors = xml[&apos;validationErrors&apos;].toString();

    if (validationErrors.length &gt; 0)
    {
      logger.error(&quot;StructuralValidationService validation errors: &quot; + validationErrors);
      channelMap.put(&apos;componentErrors&apos;,  $(&apos;componentErrors&apos;) + &quot;StructuralValidationService: Validation errors:\n&quot; + validationErrors + &quot; |\n&quot;);
    }
  }

}
catch(e)
{
  logger.error(&quot;Error in Process StructuralValidationService Response Transformer: &quot; + e.message);
  channelMap.put(&apos;componentErrors&apos;,  $(&apos;componentErrors&apos;) + &quot;Process StructuralValidationService Response Transformer:\n&quot; + e.message + &quot; |\n&quot;);
}</script>
            <type>JavaScript</type>
            <data class="map">
              <entry>
                <string>Script</string>
                <string>try
{
  logger.info(&quot;Processing StructuralValidationService web svc response&quot;);

  var resp = new XML(responseMap.get(&apos;Call StructuralValidationService&apos;).getMessage());
  logger.info(resp);


  // If validationErrors is not present in response XML, a SOAP fault was likely returned from service call.  Record the 
  // response to the componentErrors variable and don&apos;t attempt to parse the validation errors.
  if (undefined == resp..*::Body..*::validateWithFilteringResponse.*::[&apos;validationErrors&apos;])
  {
    logger.error(&quot;No validationErrors element found in StructuralValidationService response. Recording response to componentErrors variable: &quot; + resp);
    channelMap.put(&apos;componentErrors&apos;,  $(&apos;componentErrors&apos;) + &quot;StructuralValidationService:\n&quot; + resp + &quot; |\n&quot;);
  }
  else
  {
    var xml = new XML(resp..*::Body..*::[&apos;validateWithFilteringResponse&apos;].toString() );
    var validationErrors = xml[&apos;validationErrors&apos;].toString();

    if (validationErrors.length &gt; 0)
    {
      logger.error(&quot;StructuralValidationService validation errors: &quot; + validationErrors);
      channelMap.put(&apos;componentErrors&apos;,  $(&apos;componentErrors&apos;) + &quot;StructuralValidationService: Validation errors:\n&quot; + validationErrors + &quot; |\n&quot;);
    }
  }

}
catch(e)
{
  logger.error(&quot;Error in Process StructuralValidationService Response Transformer: &quot; + e.message);
  channelMap.put(&apos;componentErrors&apos;,  $(&apos;componentErrors&apos;) + &quot;Process StructuralValidationService Response Transformer:\n&quot; + e.message + &quot; |\n&quot;);
}</string>
              </entry>
            </data>
          </step>
        </steps>
        <inboundTemplate encoding="base64"></inboundTemplate>
        <outboundTemplate encoding="base64"></outboundTemplate>
        <inboundProtocol>HL7V2</inboundProtocol>
        <outboundProtocol>HL7V2</outboundProtocol>
        <inboundProperties>
          <property name="convertLFtoCR">true</property>
          <property name="handleRepetitions">false</property>
          <property name="handleSubcomponents">false</property>
          <property name="stripNamespaces">true</property>
          <property name="useStrictParser">false</property>
          <property name="useStrictValidation">false</property>
        </inboundProperties>
        <outboundProperties>
          <property name="convertLFtoCR">true</property>
          <property name="handleRepetitions">false</property>
          <property name="handleSubcomponents">false</property>
          <property name="stripNamespaces">true</property>
          <property name="useStrictParser">false</property>
          <property name="useStrictValidation">false</property>
        </outboundProperties>
      </transformer>
      <filter>
        <rules>
          <rule>
            <sequenceNumber>0</sequenceNumber>
            <name>Filter destination based on component configuration and prior errors</name>
            <data class="map">
              <entry>
                <string>Script</string>
                <string>return ($(&apos;structuralValidation&apos;) == &apos;true&apos; &amp;&amp; $(&apos;componentErrors&apos;).length() == 0);</string>
              </entry>
            </data>
            <type>JavaScript</type>
            <script>return ($(&apos;structuralValidation&apos;) == &apos;true&apos; &amp;&amp; $(&apos;componentErrors&apos;).length() == 0);</script>
            <operator>NONE</operator>
          </rule>
        </rules>
      </filter>
      <transportName>Channel Writer</transportName>
      <mode>DESTINATION</mode>
      <enabled>false</enabled>
      <version>2.2.0.5828</version>
    </connector>
    <connector>
      <name>Call VocabTranslationService</name>
      <properties>
        <property name="DataType">Web Service Sender</property>
        <property name="dispatcherAttachmentContents">&lt;list/&gt;</property>
        <property name="dispatcherAttachmentNames">&lt;list/&gt;</property>
        <property name="dispatcherAttachmentTypes">&lt;list/&gt;</property>
        <property name="dispatcherEnvelope">&lt;soapenv:Envelope xmlns:ns=&quot;http://ws.soap.mss.cdc.gov/&quot; xmlns:soapenv=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;&gt;&#xd;
  &lt;soapenv:Header/&gt;&#xd;
  &lt;soapenv:Body&gt;&#xd;
    &lt;ns:translate&gt;&#xd;
      &lt;arg0&gt;&lt;![CDATA[${message.rawData}]]&gt;&lt;/arg0&gt;&#xd;
      &lt;arg1&gt;${vocabTranslationMSSProfile}&lt;/arg1&gt;&#xd;
    &lt;/ns:translate&gt;&#xd;
  &lt;/soapenv:Body&gt;&#xd;
&lt;/soapenv:Envelope&gt;&#xd;</property>
        <property name="dispatcherOneWay">0</property>
        <property name="dispatcherOperation">processConfig</property>
        <property name="dispatcherPassword"></property>
        <property name="dispatcherPort">{http://ws.soap.mss.cdc.gov/}VocabTranslationServiceImpPort</property>
        <property name="dispatcherReplyChannelId">sink</property>
        <property name="dispatcherService">{http://ws.soap.mss.cdc.gov/}VocabTranslationServiceImpService</property>
        <property name="dispatcherSoapAction"></property>
        <property name="dispatcherUseAuthentication">0</property>
        <property name="dispatcherUseMtom">0</property>
        <property name="dispatcherUsername"></property>
        <property name="dispatcherWsdlCacheId"></property>
        <property name="dispatcherWsdlOperations">&lt;list&gt;
  &lt;string&gt;loadCache&lt;/string&gt;
  &lt;string&gt;processConfig&lt;/string&gt;
  &lt;string&gt;translate&lt;/string&gt;
&lt;/list&gt;</property>
        <property name="dispatcherWsdlUrl">http://localhost:8080/mss-services/TranslationService?wsdl</property>
        <property name="host">localhost:8080/mss-services/TranslationService?wsdl</property>
        <property name="queuePollInterval">200</property>
        <property name="reconnectMillisecs">10000</property>
        <property name="rotateQueue">0</property>
        <property name="usePersistentQueues">0</property>
      </properties>
      <transformer>
        <steps/>
        <inboundTemplate encoding="base64"></inboundTemplate>
        <inboundProtocol>HL7V2</inboundProtocol>
        <outboundProtocol>HL7V2</outboundProtocol>
        <inboundProperties>
          <property name="convertLFtoCR">true</property>
          <property name="handleRepetitions">false</property>
          <property name="handleSubcomponents">false</property>
          <property name="stripNamespaces">true</property>
          <property name="useStrictParser">false</property>
          <property name="useStrictValidation">false</property>
        </inboundProperties>
        <outboundProperties>
          <property name="convertLFtoCR">true</property>
          <property name="handleRepetitions">false</property>
          <property name="handleSubcomponents">false</property>
          <property name="stripNamespaces">true</property>
          <property name="useStrictParser">false</property>
          <property name="useStrictValidation">false</property>
        </outboundProperties>
      </transformer>
      <filter>
        <rules>
          <rule>
            <sequenceNumber>0</sequenceNumber>
            <name>Filter call to VocabTranslationService based on ComponentRoutingService configuration</name>
            <data class="map">
              <entry>
                <string>Script</string>
                <string>var retval = false;

if ($(&apos;vocabTranslation&apos;) != &apos;true&apos;)
{
  logger.info(&quot;Bypassing VocabTranslationService call based on component routing configuration&quot;);
}
else if ($(&apos;hubHost&apos;) != $(&apos;receivingFacilityHubHost&apos;))
{
  logger.info(&quot;Bypassing VocabTranslationService since msg is not yet at Destination Facility&quot;);
}
else if ($(&apos;componentErrors&apos;).length() &gt; 0)
{&#xd;  logger.info(&quot;Bypassing VocabTranslationService call because of prior errors: &quot; + $(&apos;componentErrors&apos;));
}
else
{
  logger.info(&quot;Calling VocabTranslationService&quot;);
  retval = true;
}

if (retval)
{
  channelMap.put(&apos;vocabTranslationCallStatus&apos;, &apos;CALLED&apos;);
}
else
{
  channelMap.put(&apos;vocabTranslationCallStatus&apos;, &apos;BYPASSED&apos;);
}

return retval;</string>
              </entry>
            </data>
            <type>JavaScript</type>
            <script>var retval = false;

if ($(&apos;vocabTranslation&apos;) != &apos;true&apos;)
{
  logger.info(&quot;Bypassing VocabTranslationService call based on component routing configuration&quot;);
}
else if ($(&apos;hubHost&apos;) != $(&apos;receivingFacilityHubHost&apos;))
{
  logger.info(&quot;Bypassing VocabTranslationService since msg is not yet at Destination Facility&quot;);
}
else if ($(&apos;componentErrors&apos;).length() &gt; 0)
{&#xd;  logger.info(&quot;Bypassing VocabTranslationService call because of prior errors: &quot; + $(&apos;componentErrors&apos;));
}
else
{
  logger.info(&quot;Calling VocabTranslationService&quot;);
  retval = true;
}

if (retval)
{
  channelMap.put(&apos;vocabTranslationCallStatus&apos;, &apos;CALLED&apos;);
}
else
{
  channelMap.put(&apos;vocabTranslationCallStatus&apos;, &apos;BYPASSED&apos;);
}

return retval;</script>
            <operator>NONE</operator>
          </rule>
        </rules>
      </filter>
      <transportName>Web Service Sender</transportName>
      <mode>DESTINATION</mode>
      <enabled>true</enabled>
      <version>2.2.0.5828</version>
    </connector>
    <connector>
      <name>Process VocabTranslationService Response</name>
      <properties>
        <property name="DataType">Channel Writer</property>
        <property name="host">sink</property>
        <property name="synchronised">0</property>
        <property name="template">${message.encodedData}</property>
      </properties>
      <transformer>
        <steps>
          <step>
            <sequenceNumber>0</sequenceNumber>
            <name>process VocabTranslationService web service response</name>
            <script>try
{
  logger.info(&quot;Processing VocabTranslationService web svc response&quot;);

  var resp = new XML(responseMap.get(&apos;Call VocabTranslationService&apos;).getMessage());
  logger.info(resp);

  // If translateResponse/return is not present in response XML, a SOAP fault was likely returned from service call.
  // Record the response to the componentErrors variable and don&apos;t attempt to parse results.
  if (undefined == resp..*::Body..*::translateResponse..*::[&apos;return&apos;])
  {
    logger.error(&quot;No translateResponse/return element found in VocabTranslationService response. Recording response to componentErrors variable: &quot; + resp);
    channelMap.put(&apos;componentErrors&apos;,  $(&apos;componentErrors&apos;) + &quot;VocabTranslationService:\n&quot; + resp + &quot; |\n&quot;);
  }
  else
  {
    var translatedMsg = new XML(resp..*::Body..*::translateResponse..*::[&apos;return&apos;].toString());
    logger.info(&quot;translatedMsg: --&gt;&quot; + translatedMsg + &quot;&lt;--&quot;);

    var translatedXML = SerializerFactory.getHL7Serializer().toXML(translatedMsg.toString() );
    logger.info(&quot;translatedXML:&quot; + translatedXML.toString() );

    var translatedXMLObj = new XML(translatedXML);

    if (msg[&apos;OBX&apos;].length() &gt; 0)
    {
      logger.info(&quot;Found OBX segment, setting std vocab in channel map&quot;);

      channelMap.put(&apos;stdObx31&apos;, translatedXMLObj..*::OBX.*::[&apos;OBX.3&apos;].*::[&apos;OBX.3.1&apos;].toString() );
      channelMap.put(&apos;stdObx32&apos;, translatedXMLObj..*::OBX.*::[&apos;OBX.3&apos;].*::[&apos;OBX.3.2&apos;].toString() );
      channelMap.put(&apos;stdObx33&apos;, translatedXMLObj..*::OBX.*::[&apos;OBX.3&apos;].*::[&apos;OBX.3.3&apos;].toString() );

      logger.info(&quot;stdObx31: &quot; + channelMap.get(&apos;stdObx31&apos;) );
      logger.info(&quot;stdObx32: &quot; + channelMap.get(&apos;stdObx32&apos;) );
      logger.info(&quot;stdObx33: &quot; + channelMap.get(&apos;stdObx33&apos;) );
    }

    if (msg[&apos;RXA&apos;].length() &gt; 0)
    {
      logger.info(&quot;Found RXA segment, setting std vocab in channel map&quot;);

      channelMap.put(&apos;stdRxa51&apos;, translatedXMLObj..*::RXA.*::[&apos;RXA.5&apos;].*::[&apos;RXA.5.1&apos;].toString() );
      channelMap.put(&apos;stdRxa52&apos;, translatedXMLObj..*::RXA.*::[&apos;RXA.5&apos;].*::[&apos;RXA.5.2&apos;].toString() );
      channelMap.put(&apos;stdRxa53&apos;, translatedXMLObj..*::RXA.*::[&apos;RXA.5&apos;].*::[&apos;RXA.5.3&apos;].toString() );

      logger.info(&quot;stdRxa51: &quot; + channelMap.get(&apos;stdRxa51&apos;) );
      logger.info(&quot;stdRxa52: &quot; + channelMap.get(&apos;stdRxa52&apos;) );
      logger.info(&quot;stdRxa53: &quot; + channelMap.get(&apos;stdRxa53&apos;) );
    }
  }

}
catch(e)
{
  logger.error(&quot;Error in Process VocabTranslationService Response Transformer: &quot; + e.message);
  channelMap.put(&apos;componentErrors&apos;,  $(&apos;componentErrors&apos;) + &quot;Process VocabTranslationService Response Transformer:\n&quot; + e.message + &quot; |\n&quot;);
}</script>
            <type>JavaScript</type>
            <data class="map">
              <entry>
                <string>Script</string>
                <string>try
{
  logger.info(&quot;Processing VocabTranslationService web svc response&quot;);

  var resp = new XML(responseMap.get(&apos;Call VocabTranslationService&apos;).getMessage());
  logger.info(resp);

  // If translateResponse/return is not present in response XML, a SOAP fault was likely returned from service call.
  // Record the response to the componentErrors variable and don&apos;t attempt to parse results.
  if (undefined == resp..*::Body..*::translateResponse..*::[&apos;return&apos;])
  {
    logger.error(&quot;No translateResponse/return element found in VocabTranslationService response. Recording response to componentErrors variable: &quot; + resp);
    channelMap.put(&apos;componentErrors&apos;,  $(&apos;componentErrors&apos;) + &quot;VocabTranslationService:\n&quot; + resp + &quot; |\n&quot;);
  }
  else
  {
    var translatedMsg = new XML(resp..*::Body..*::translateResponse..*::[&apos;return&apos;].toString());
    logger.info(&quot;translatedMsg: --&gt;&quot; + translatedMsg + &quot;&lt;--&quot;);

    var translatedXML = SerializerFactory.getHL7Serializer().toXML(translatedMsg.toString() );
    logger.info(&quot;translatedXML:&quot; + translatedXML.toString() );

    var translatedXMLObj = new XML(translatedXML);

    if (msg[&apos;OBX&apos;].length() &gt; 0)
    {
      logger.info(&quot;Found OBX segment, setting std vocab in channel map&quot;);

      channelMap.put(&apos;stdObx31&apos;, translatedXMLObj..*::OBX.*::[&apos;OBX.3&apos;].*::[&apos;OBX.3.1&apos;].toString() );
      channelMap.put(&apos;stdObx32&apos;, translatedXMLObj..*::OBX.*::[&apos;OBX.3&apos;].*::[&apos;OBX.3.2&apos;].toString() );
      channelMap.put(&apos;stdObx33&apos;, translatedXMLObj..*::OBX.*::[&apos;OBX.3&apos;].*::[&apos;OBX.3.3&apos;].toString() );

      logger.info(&quot;stdObx31: &quot; + channelMap.get(&apos;stdObx31&apos;) );
      logger.info(&quot;stdObx32: &quot; + channelMap.get(&apos;stdObx32&apos;) );
      logger.info(&quot;stdObx33: &quot; + channelMap.get(&apos;stdObx33&apos;) );
    }

    if (msg[&apos;RXA&apos;].length() &gt; 0)
    {
      logger.info(&quot;Found RXA segment, setting std vocab in channel map&quot;);

      channelMap.put(&apos;stdRxa51&apos;, translatedXMLObj..*::RXA.*::[&apos;RXA.5&apos;].*::[&apos;RXA.5.1&apos;].toString() );
      channelMap.put(&apos;stdRxa52&apos;, translatedXMLObj..*::RXA.*::[&apos;RXA.5&apos;].*::[&apos;RXA.5.2&apos;].toString() );
      channelMap.put(&apos;stdRxa53&apos;, translatedXMLObj..*::RXA.*::[&apos;RXA.5&apos;].*::[&apos;RXA.5.3&apos;].toString() );

      logger.info(&quot;stdRxa51: &quot; + channelMap.get(&apos;stdRxa51&apos;) );
      logger.info(&quot;stdRxa52: &quot; + channelMap.get(&apos;stdRxa52&apos;) );
      logger.info(&quot;stdRxa53: &quot; + channelMap.get(&apos;stdRxa53&apos;) );
    }
  }

}
catch(e)
{
  logger.error(&quot;Error in Process VocabTranslationService Response Transformer: &quot; + e.message);
  channelMap.put(&apos;componentErrors&apos;,  $(&apos;componentErrors&apos;) + &quot;Process VocabTranslationService Response Transformer:\n&quot; + e.message + &quot; |\n&quot;);
}</string>
              </entry>
            </data>
          </step>
        </steps>
        <inboundTemplate encoding="base64"></inboundTemplate>
        <outboundTemplate encoding="base64"></outboundTemplate>
        <inboundProtocol>HL7V2</inboundProtocol>
        <outboundProtocol>HL7V2</outboundProtocol>
        <inboundProperties>
          <property name="convertLFtoCR">true</property>
          <property name="handleRepetitions">false</property>
          <property name="handleSubcomponents">false</property>
          <property name="stripNamespaces">true</property>
          <property name="useStrictParser">false</property>
          <property name="useStrictValidation">false</property>
        </inboundProperties>
        <outboundProperties>
          <property name="convertLFtoCR">true</property>
          <property name="handleRepetitions">false</property>
          <property name="handleSubcomponents">false</property>
          <property name="stripNamespaces">true</property>
          <property name="useStrictParser">false</property>
          <property name="useStrictValidation">false</property>
        </outboundProperties>
      </transformer>
      <filter>
        <rules>
          <rule>
            <sequenceNumber>0</sequenceNumber>
            <name>Filter destination based on component configuration and prior errors</name>
            <data class="map">
              <entry>
                <string>Script</string>
                <string>return ($(&apos;vocabTranslation&apos;) == &apos;true&apos; &amp;&amp; 
        $(&apos;componentErrors&apos;).length() == 0 &amp;&amp;
        $(&apos;hubHost&apos;) == $(&apos;receivingFacilityHubHost&apos;));</string>
              </entry>
            </data>
            <type>JavaScript</type>
            <script>return ($(&apos;vocabTranslation&apos;) == &apos;true&apos; &amp;&amp; 
        $(&apos;componentErrors&apos;).length() == 0 &amp;&amp;
        $(&apos;hubHost&apos;) == $(&apos;receivingFacilityHubHost&apos;));</script>
            <operator>NONE</operator>
          </rule>
        </rules>
      </filter>
      <transportName>Channel Writer</transportName>
      <mode>DESTINATION</mode>
      <enabled>true</enabled>
      <version>2.2.0.5828</version>
    </connector>
    <connector>
      <name>Call CodeValidationService</name>
      <properties>
        <property name="DataType">Web Service Sender</property>
        <property name="dispatcherAttachmentContents">&lt;list/&gt;</property>
        <property name="dispatcherAttachmentNames">&lt;list/&gt;</property>
        <property name="dispatcherAttachmentTypes">&lt;list/&gt;</property>
        <property name="dispatcherEnvelope">&lt;soapenv:Envelope xmlns:ns=&quot;http://validator.vocabulary.mss.cdc.gov/&quot; xmlns:soapenv=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;&gt;&#xd;
  &lt;soapenv:Header/&gt;&#xd;
  &lt;soapenv:Body&gt;&#xd;
    &lt;ns:processMessage&gt;&#xd;
      &lt;arg0&gt;&lt;![CDATA[${message.rawData}]]&gt;&lt;/arg0&gt;
      &lt;arg1&gt;${codeValidationMSSProfile}&lt;/arg1&gt;
      &lt;arg2&gt;HL7 ${msgHL7VersionID}&lt;/arg2&gt;
    &lt;/ns:processMessage&gt;&#xd;
  &lt;/soapenv:Body&gt;&#xd;
&lt;/soapenv:Envelope&gt;&#xd;</property>
        <property name="dispatcherOneWay">0</property>
        <property name="dispatcherOperation">processMessage</property>
        <property name="dispatcherPassword"></property>
        <property name="dispatcherPort">{http://validator.vocabulary.mss.cdc.gov/}CodeValidationServicePort</property>
        <property name="dispatcherReplyChannelId">sink</property>
        <property name="dispatcherService">{http://validator.vocabulary.mss.cdc.gov/}CodeValidationServiceService</property>
        <property name="dispatcherSoapAction"></property>
        <property name="dispatcherUseAuthentication">0</property>
        <property name="dispatcherUseMtom">0</property>
        <property name="dispatcherUsername"></property>
        <property name="dispatcherWsdlCacheId"></property>
        <property name="dispatcherWsdlOperations">&lt;list&gt;
  &lt;string&gt;getFields&lt;/string&gt;
  &lt;string&gt;loadCache&lt;/string&gt;
  &lt;string&gt;processMessage&lt;/string&gt;
  &lt;string&gt;updateCodeSet&lt;/string&gt;
  &lt;string&gt;updateCsXpath&lt;/string&gt;
  &lt;string&gt;updateFields&lt;/string&gt;
  &lt;string&gt;updateProfile&lt;/string&gt;
  &lt;string&gt;updateValueSet&lt;/string&gt;
&lt;/list&gt;</property>
        <property name="dispatcherWsdlUrl">http://localhost:8080/mss-services/CodeValidationService?wsdl</property>
        <property name="host">localhost:8080/mss-services/CodeValidationService?wsdl</property>
        <property name="queuePollInterval">200</property>
        <property name="reconnectMillisecs">10000</property>
        <property name="rotateQueue">0</property>
        <property name="usePersistentQueues">0</property>
      </properties>
      <transformer>
        <steps/>
        <inboundTemplate encoding="base64"></inboundTemplate>
        <outboundTemplate encoding="base64"></outboundTemplate>
        <inboundProtocol>HL7V2</inboundProtocol>
        <outboundProtocol>HL7V2</outboundProtocol>
        <inboundProperties>
          <property name="convertLFtoCR">true</property>
          <property name="handleRepetitions">false</property>
          <property name="handleSubcomponents">false</property>
          <property name="stripNamespaces">true</property>
          <property name="useStrictParser">false</property>
          <property name="useStrictValidation">false</property>
        </inboundProperties>
        <outboundProperties>
          <property name="convertLFtoCR">true</property>
          <property name="handleRepetitions">false</property>
          <property name="handleSubcomponents">false</property>
          <property name="stripNamespaces">true</property>
          <property name="useStrictParser">false</property>
          <property name="useStrictValidation">false</property>
        </outboundProperties>
      </transformer>
      <filter>
        <rules>
          <rule>
            <sequenceNumber>0</sequenceNumber>
            <name>Filter call to CodeValidationService based on ComponentRoutingService configuration</name>
            <data class="map">
              <entry>
                <string>Script</string>
                <string>var retval = false;

if ($(&apos;codeValidation&apos;) != &apos;true&apos;)
{
  logger.info(&quot;Bypassing CodeValidationService call based on component routing configuration&quot;);
}
else if ($(&apos;hubHost&apos;) != $(&apos;receivingFacilityHubHost&apos;))
{
  logger.info(&quot;Bypassing CodeValidationService since msg is not yet at Destination Facility&quot;);
}
else if ($(&apos;componentErrors&apos;).length() &gt; 0)
{
  logger.info(&quot;Bypassing CodeValidationService call because of prior errors: &quot; + $(&apos;componentErrors&apos;));
}
else
{
  logger.info(&quot;Calling CodeValidationService&quot;);
  retval = true;
}

if (retval)
{
  channelMap.put(&apos;codeValidationCallStatus&apos;, &apos;CALLED&apos;);
}
else
{
  channelMap.put(&apos;codeValidationCallStatus&apos;, &apos;BYPASSED&apos;);
}

return retval;</string>
              </entry>
            </data>
            <type>JavaScript</type>
            <script>var retval = false;

if ($(&apos;codeValidation&apos;) != &apos;true&apos;)
{
  logger.info(&quot;Bypassing CodeValidationService call based on component routing configuration&quot;);
}
else if ($(&apos;hubHost&apos;) != $(&apos;receivingFacilityHubHost&apos;))
{
  logger.info(&quot;Bypassing CodeValidationService since msg is not yet at Destination Facility&quot;);
}
else if ($(&apos;componentErrors&apos;).length() &gt; 0)
{
  logger.info(&quot;Bypassing CodeValidationService call because of prior errors: &quot; + $(&apos;componentErrors&apos;));
}
else
{
  logger.info(&quot;Calling CodeValidationService&quot;);
  retval = true;
}

if (retval)
{
  channelMap.put(&apos;codeValidationCallStatus&apos;, &apos;CALLED&apos;);
}
else
{
  channelMap.put(&apos;codeValidationCallStatus&apos;, &apos;BYPASSED&apos;);
}

return retval;</script>
            <operator>NONE</operator>
          </rule>
        </rules>
      </filter>
      <transportName>Web Service Sender</transportName>
      <mode>DESTINATION</mode>
      <enabled>true</enabled>
      <version>2.2.0.5828</version>
    </connector>
    <connector>
      <name>Process CodeValidationService Response</name>
      <properties>
        <property name="DataType">Channel Writer</property>
        <property name="host">sink</property>
        <property name="synchronised">0</property>
        <property name="template">${message.encodedData}</property>
      </properties>
      <transformer>
        <steps>
          <step>
            <sequenceNumber>0</sequenceNumber>
            <name>process CodeValidationService web service response</name>
            <script>try
{
  logger.info(&quot;Processing CodeValidationService web svc response&quot;);

  var resp = new XML(responseMap.get(&apos;Call CodeValidationService&apos;).getMessage());
  logger.info(resp);

  // If processMessageResponse/return is not present in response XML, a SOAP fault was likely returned from service call.
  // Record the response to the componentErrors variable and don&apos;t attempt to parse results.
  if (undefined == resp..*::Body..*::processMessageResponse..*::[&apos;return&apos;])
  {
    logger.error(&quot;No processMessageResponse/return element found in CodeValidationService response. Recording response to componentErrors variable: &quot; + resp);
    channelMap.put(&apos;componentErrors&apos;,  $(&apos;componentErrors&apos;) + &quot;CodeValidationService:\n&quot; + resp + &quot; |\n&quot;);
  }
  else
  {
    var xml = new XML(resp..*::Body..*::processMessageResponse..*::[&apos;return&apos;].toString());
    logger.info(&quot;XML: &quot; + xml.toString() );

    var errors = xml.field.(status == &quot;INVALID&quot;).errormessage.toString();

    if (errors.length &gt; 0)
    {
      logger.error(&quot;CodeValidationService validation error: &quot; + errors);
      channelMap.put(&apos;componentErrors&apos;,  $(&apos;componentErrors&apos;) + &quot;CodeValidationService:\n&quot; + errors + &quot; |\n&quot;);
    }
  }

}
catch(e)
{
  logger.error(&quot;Error in Process CodeValidationService Response Transformer: &quot; + e.message);
  channelMap.put(&apos;componentErrors&apos;,  $(&apos;componentErrors&apos;) + &quot;Process CodeValidationService Response Transformer:\n&quot; + e.message + &quot; |\n&quot;);
}</script>
            <type>JavaScript</type>
            <data class="map">
              <entry>
                <string>Script</string>
                <string>try
{
  logger.info(&quot;Processing CodeValidationService web svc response&quot;);

  var resp = new XML(responseMap.get(&apos;Call CodeValidationService&apos;).getMessage());
  logger.info(resp);

  // If processMessageResponse/return is not present in response XML, a SOAP fault was likely returned from service call.
  // Record the response to the componentErrors variable and don&apos;t attempt to parse results.
  if (undefined == resp..*::Body..*::processMessageResponse..*::[&apos;return&apos;])
  {
    logger.error(&quot;No processMessageResponse/return element found in CodeValidationService response. Recording response to componentErrors variable: &quot; + resp);
    channelMap.put(&apos;componentErrors&apos;,  $(&apos;componentErrors&apos;) + &quot;CodeValidationService:\n&quot; + resp + &quot; |\n&quot;);
  }
  else
  {
    var xml = new XML(resp..*::Body..*::processMessageResponse..*::[&apos;return&apos;].toString());
    logger.info(&quot;XML: &quot; + xml.toString() );

    var errors = xml.field.(status == &quot;INVALID&quot;).errormessage.toString();

    if (errors.length &gt; 0)
    {
      logger.error(&quot;CodeValidationService validation error: &quot; + errors);
      channelMap.put(&apos;componentErrors&apos;,  $(&apos;componentErrors&apos;) + &quot;CodeValidationService:\n&quot; + errors + &quot; |\n&quot;);
    }
  }

}
catch(e)
{
  logger.error(&quot;Error in Process CodeValidationService Response Transformer: &quot; + e.message);
  channelMap.put(&apos;componentErrors&apos;,  $(&apos;componentErrors&apos;) + &quot;Process CodeValidationService Response Transformer:\n&quot; + e.message + &quot; |\n&quot;);
}</string>
              </entry>
            </data>
          </step>
        </steps>
        <inboundTemplate encoding="base64"></inboundTemplate>
        <outboundTemplate encoding="base64"></outboundTemplate>
        <inboundProtocol>HL7V2</inboundProtocol>
        <outboundProtocol>HL7V2</outboundProtocol>
        <inboundProperties>
          <property name="convertLFtoCR">true</property>
          <property name="handleRepetitions">false</property>
          <property name="handleSubcomponents">false</property>
          <property name="stripNamespaces">true</property>
          <property name="useStrictParser">false</property>
          <property name="useStrictValidation">false</property>
        </inboundProperties>
        <outboundProperties>
          <property name="convertLFtoCR">true</property>
          <property name="handleRepetitions">false</property>
          <property name="handleSubcomponents">false</property>
          <property name="stripNamespaces">true</property>
          <property name="useStrictParser">false</property>
          <property name="useStrictValidation">false</property>
        </outboundProperties>
      </transformer>
      <filter>
        <rules>
          <rule>
            <sequenceNumber>0</sequenceNumber>
            <name>Filter destination based on component configuration and prior errors</name>
            <data class="map">
              <entry>
                <string>Script</string>
                <string>return ($(&apos;codeValidation&apos;) == &apos;true&apos; &amp;&amp; 
        $(&apos;componentErrors&apos;).length() == 0 &amp;&amp;
        $(&apos;hubHost&apos;) == $(&apos;receivingFacilityHubHost&apos;));</string>
              </entry>
            </data>
            <type>JavaScript</type>
            <script>return ($(&apos;codeValidation&apos;) == &apos;true&apos; &amp;&amp; 
        $(&apos;componentErrors&apos;).length() == 0 &amp;&amp;
        $(&apos;hubHost&apos;) == $(&apos;receivingFacilityHubHost&apos;));</script>
            <operator>NONE</operator>
          </rule>
        </rules>
      </filter>
      <transportName>Channel Writer</transportName>
      <mode>DESTINATION</mode>
      <enabled>true</enabled>
      <version>2.2.0.5828</version>
    </connector>
    <connector>
      <name>Call SubscriptionService</name>
      <properties>
        <property name="DataType">Web Service Sender</property>
        <property name="dispatcherAttachmentContents">&lt;list/&gt;</property>
        <property name="dispatcherAttachmentNames">&lt;list/&gt;</property>
        <property name="dispatcherAttachmentTypes">&lt;list/&gt;</property>
        <property name="dispatcherEnvelope">&lt;soapenv:Envelope xmlns:ns=&quot;http://subscription.mss.cdc.gov/&quot; xmlns:soapenv=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;&gt;&#xd;
  &lt;soapenv:Header/&gt;&#xd;
  &lt;soapenv:Body&gt;&#xd;
    &lt;ns:processMessage&gt;&#xd;
      &lt;!-- arg0: hl7 message to evaluate for subscriptions --&gt;&#xd;
      &lt;arg0&gt;&lt;![CDATA[${message.encodedData}]]&gt;&lt;/arg0&gt;
    &lt;/ns:processMessage&gt;&#xd;
  &lt;/soapenv:Body&gt;&#xd;
&lt;/soapenv:Envelope&gt;&#xd;
</property>
        <property name="dispatcherOneWay">0</property>
        <property name="dispatcherOperation">processMessage</property>
        <property name="dispatcherPassword"></property>
        <property name="dispatcherPort">{http://subscription.mss.cdc.gov/}SubscriptionServicePort</property>
        <property name="dispatcherReplyChannelId">sink</property>
        <property name="dispatcherService">{http://subscription.mss.cdc.gov/}SubscriptionServiceService</property>
        <property name="dispatcherSoapAction"></property>
        <property name="dispatcherUseAuthentication">0</property>
        <property name="dispatcherUseMtom">0</property>
        <property name="dispatcherUsername"></property>
        <property name="dispatcherWsdlOperations">&lt;list&gt;
  &lt;string&gt;processMessage&lt;/string&gt;
&lt;/list&gt;</property>
        <property name="dispatcherWsdlUrl">http://localhost:8080/mss-services/SubscriptionService?wsdl</property>
        <property name="host">localhost:8080/mss-services/SubscriptionService?wsdl</property>
        <property name="queuePollInterval">200</property>
        <property name="reconnectMillisecs">10000</property>
        <property name="rotateQueue">0</property>
        <property name="usePersistentQueues">0</property>
      </properties>
      <transformer>
        <steps>
          <step>
            <sequenceNumber>0</sequenceNumber>
            <name>Apply Vocab Transformation</name>
            <script>// vocab transformation must be applied before subscription svc invoked, since
// subscription svc requires standardized vocabulary

// -- vocab translation --
if ( $(&apos;stdObx31&apos;) != &apos;&apos; )
{
  logger.info(&quot;Applying OBX.3 vocab translation to msg prior to subscription svc call...&quot;);
  msg[&apos;OBX&apos;][&apos;OBX.3&apos;][&apos;OBX.3.1&apos;] = $(&apos;stdObx31&apos;);
  msg[&apos;OBX&apos;][&apos;OBX.3&apos;][&apos;OBX.3.2&apos;] = $(&apos;stdObx32&apos;);
  msg[&apos;OBX&apos;][&apos;OBX.3&apos;][&apos;OBX.3.3&apos;] = $(&apos;stdObx33&apos;);
}

if ( $(&apos;stdRxa51&apos;) != &apos;&apos; )
{
  logger.info(&quot;Applying RXA.5 vocab translation to msg prior to subscription svc call...&quot;);
  msg[&apos;RXA&apos;][&apos;RXA.5&apos;][&apos;RXA.5.1&apos;] = $(&apos;stdRxa51&apos;);
  msg[&apos;RXA&apos;][&apos;RXA.5&apos;][&apos;RXA.5.2&apos;] = $(&apos;stdRxa52&apos;);
  msg[&apos;RXA&apos;][&apos;RXA.5&apos;][&apos;RXA.5.3&apos;] = $(&apos;stdRxa53&apos;);
}</script>
            <type>JavaScript</type>
            <data class="map">
              <entry>
                <string>Script</string>
                <string>// vocab transformation must be applied before subscription svc invoked, since
// subscription svc requires standardized vocabulary

// -- vocab translation --
if ( $(&apos;stdObx31&apos;) != &apos;&apos; )
{
  logger.info(&quot;Applying OBX.3 vocab translation to msg prior to subscription svc call...&quot;);
  msg[&apos;OBX&apos;][&apos;OBX.3&apos;][&apos;OBX.3.1&apos;] = $(&apos;stdObx31&apos;);
  msg[&apos;OBX&apos;][&apos;OBX.3&apos;][&apos;OBX.3.2&apos;] = $(&apos;stdObx32&apos;);
  msg[&apos;OBX&apos;][&apos;OBX.3&apos;][&apos;OBX.3.3&apos;] = $(&apos;stdObx33&apos;);
}

if ( $(&apos;stdRxa51&apos;) != &apos;&apos; )
{
  logger.info(&quot;Applying RXA.5 vocab translation to msg prior to subscription svc call...&quot;);
  msg[&apos;RXA&apos;][&apos;RXA.5&apos;][&apos;RXA.5.1&apos;] = $(&apos;stdRxa51&apos;);
  msg[&apos;RXA&apos;][&apos;RXA.5&apos;][&apos;RXA.5.2&apos;] = $(&apos;stdRxa52&apos;);
  msg[&apos;RXA&apos;][&apos;RXA.5&apos;][&apos;RXA.5.3&apos;] = $(&apos;stdRxa53&apos;);
}</string>
              </entry>
            </data>
          </step>
        </steps>
        <inboundTemplate encoding="base64"></inboundTemplate>
        <outboundTemplate encoding="base64"></outboundTemplate>
        <inboundProtocol>HL7V2</inboundProtocol>
        <outboundProtocol>HL7V2</outboundProtocol>
        <inboundProperties>
          <property name="convertLFtoCR">true</property>
          <property name="handleRepetitions">false</property>
          <property name="handleSubcomponents">false</property>
          <property name="stripNamespaces">true</property>
          <property name="useStrictParser">false</property>
          <property name="useStrictValidation">false</property>
        </inboundProperties>
        <outboundProperties>
          <property name="convertLFtoCR">true</property>
          <property name="handleRepetitions">false</property>
          <property name="handleSubcomponents">false</property>
          <property name="stripNamespaces">true</property>
          <property name="useStrictParser">false</property>
          <property name="useStrictValidation">false</property>
        </outboundProperties>
      </transformer>
      <filter>
        <rules>
          <rule>
            <sequenceNumber>0</sequenceNumber>
            <name>Filter call to SubscriptionService based on ComponentRoutingService configuration</name>
            <data class="map">
              <entry>
                <string>Script</string>
                <string>var retval = false;

if ($(&apos;subscription&apos;) != &apos;true&apos;)
{
  logger.info(&quot;Bypassing SubscriptionService call based on component routing configuration&quot;);
}
else if ($(&apos;hubHost&apos;) != $(&apos;receivingFacilityHubHost&apos;))
{
  logger.info(&quot;Bypassing SubscriptionService since msg is not yet at Destination Facility&quot;);
}
else if ($(&apos;componentErrors&apos;).length() &gt; 0)
{
  logger.info(&quot;Bypassing SubscriptionService call because of prior errors: &quot; + $(&apos;componentErrors&apos;));
}
else
{
  logger.info(&quot;Calling SubscriptionService&quot;);
  retval = true;
}

if (retval)
{
  channelMap.put(&apos;subscriptionCallStatus&apos;, &apos;CALLED&apos;);
}
else
{
  channelMap.put(&apos;subscriptionCallStatus&apos;, &apos;BYPASSED&apos;);
}

return retval;</string>
              </entry>
            </data>
            <type>JavaScript</type>
            <script>var retval = false;

if ($(&apos;subscription&apos;) != &apos;true&apos;)
{
  logger.info(&quot;Bypassing SubscriptionService call based on component routing configuration&quot;);
}
else if ($(&apos;hubHost&apos;) != $(&apos;receivingFacilityHubHost&apos;))
{
  logger.info(&quot;Bypassing SubscriptionService since msg is not yet at Destination Facility&quot;);
}
else if ($(&apos;componentErrors&apos;).length() &gt; 0)
{
  logger.info(&quot;Bypassing SubscriptionService call because of prior errors: &quot; + $(&apos;componentErrors&apos;));
}
else
{
  logger.info(&quot;Calling SubscriptionService&quot;);
  retval = true;
}

if (retval)
{
  channelMap.put(&apos;subscriptionCallStatus&apos;, &apos;CALLED&apos;);
}
else
{
  channelMap.put(&apos;subscriptionCallStatus&apos;, &apos;BYPASSED&apos;);
}

return retval;</script>
            <operator>NONE</operator>
          </rule>
        </rules>
      </filter>
      <transportName>Web Service Sender</transportName>
      <mode>DESTINATION</mode>
      <enabled>true</enabled>
      <version>2.2.0.5828</version>
    </connector>
    <connector>
      <name>Process SubscriptionService Response</name>
      <properties>
        <property name="DataType">Channel Writer</property>
        <property name="host">sink</property>
        <property name="synchronised">0</property>
        <property name="template">${message.encodedData}</property>
      </properties>
      <transformer>
        <steps>
          <step>
            <sequenceNumber>0</sequenceNumber>
            <name>process SubscriptionService web service response</name>
            <script>try
{
  logger.info(&quot;Processing SubscriptionService web svc response&quot;);

  var resp = new XML(responseMap.get(&apos;Call SubscriptionService&apos;).getMessage());
  logger.info(resp);

  // If processMessageResponse/return is not present in response XML, a SOAP fault was likely returned from service call.
  // Record the response to the componentErrors variable and don&apos;t attempt to parse results.
  if (undefined == resp..*::Body..*::processMessageResponse..*::[&apos;return&apos;])
  {
    logger.error(&quot;No processMessageResponse/return element found in SubscriptionService response. Recording response to componentErrors variable: &quot; + resp);
    channelMap.put(&apos;componentErrors&apos;,  $(&apos;componentErrors&apos;) + &quot;SubscriptionService:\n&quot; + resp + &quot; |\n&quot;);
  }
  else
  {
    var xml = new XML(resp..*::Body..*::processMessageResponse..*::[&apos;return&apos;].toString());
    logger.info(&quot;XML: &quot; + xml.toString() );
	
	var matchobx3 = false; 
	var matchobx5 = false;
	for each(rules in xml..rules)
	{
		var subName = rules.destinationaddress.toString();

    	if (subName.length &gt; 0)
	    {
      		if(subName == &quot;CANR&quot;) 
			{
				matchobx3 = true; 
			}
			else if(subName == &quot;CAN&quot;)
			{
				matchobx5 = true; 
			}
		}
	}
	
    var subName = xml.rules.destinationaddress.toString();

    if (subName.length &gt; 0)
    {
      logger.info(&quot;Subscription criteria met for subscription: &quot; + subName);
      channelMap.put(&apos;subscriptionName&apos;, subName );

      var subRuleName = xml.rules.rulename.toString();
      logger.info(&quot;Rule name: &quot; + subRuleName);

      channelMap.put(&apos;subscriptionRuleName&apos;, subRuleName );

      // Determine subscription descriptive name based on short name.  This is used
      // in email alert.
      var subscriptionDesc;
      if (subName == &quot;SAL&quot;) 
      {
        subscriptionDesc = &quot;Salmonellosis&quot;;
      }
      else if (subName == &quot;HEP&quot;)
      {
        subscriptionDesc = &quot;Hepatitis C&quot;;
      }
      else if (subName == &quot;FLU&quot;)
      {
        subscriptionDesc = &quot;Influenza&quot;;
      }  
      else if (subName == &quot;ADT&quot;)
      {
        subscriptionDesc = &quot;ADT&quot;;
      }
      else if (subName == &quot;IMM&quot;)
      {
        subscriptionDesc = &quot;Immunization&quot;;
      }
      else if (subName == &quot;DOH1&quot;)
      {
        subscriptionDesc = &quot;Electronic Test Order &amp; Result (ETOR)&quot;;
      }
	  else if (matchobx3 &amp;&amp; matchobx5)
	  {
		subscriptionDesc =  &quot;Cancer Registry&quot;;
	  }
      else 
      {
        subscriptionDesc = &quot;Unkonwn subscription: &quot; + subName;
      }
    
      channelMap.put(&apos;subscriptionDesc&apos;, subscriptionDesc );

      channelMap.put(&apos;obx51&apos;, msg[&apos;OBX&apos;][&apos;OBX.5&apos;][&apos;OBX.5.1&apos;].toString() );
      channelMap.put(&apos;obx52&apos;, msg[&apos;OBX&apos;][&apos;OBX.5&apos;][&apos;OBX.5.2&apos;].toString() );

      channelMap.put(&apos;placerOrderNumberEntityID&apos;, msg[&apos;OBR&apos;][&apos;OBR.2&apos;][&apos;OBR.2.1&apos;].toString() );                                  

      logger.info(&quot;Rule name: &quot; + subRuleName);
    }
    else
    {
      logger.info(&quot;No subscriptions for msg.&quot;);
    }
  }

}
catch(e)
{
  logger.error(&quot;Error in Process SubscriptionService Response Transformer: &quot; + e.message);
  channelMap.put(&apos;componentErrors&apos;,  $(&apos;componentErrors&apos;) + &quot;Process SubscriptionService Response Transformer:\n&quot; + e.message + &quot; |\n&quot;);
}</script>
            <type>JavaScript</type>
            <data class="map">
              <entry>
                <string>Script</string>
                <string>try
{
  logger.info(&quot;Processing SubscriptionService web svc response&quot;);

  var resp = new XML(responseMap.get(&apos;Call SubscriptionService&apos;).getMessage());
  logger.info(resp);

  // If processMessageResponse/return is not present in response XML, a SOAP fault was likely returned from service call.
  // Record the response to the componentErrors variable and don&apos;t attempt to parse results.
  if (undefined == resp..*::Body..*::processMessageResponse..*::[&apos;return&apos;])
  {
    logger.error(&quot;No processMessageResponse/return element found in SubscriptionService response. Recording response to componentErrors variable: &quot; + resp);
    channelMap.put(&apos;componentErrors&apos;,  $(&apos;componentErrors&apos;) + &quot;SubscriptionService:\n&quot; + resp + &quot; |\n&quot;);
  }
  else
  {
    var xml = new XML(resp..*::Body..*::processMessageResponse..*::[&apos;return&apos;].toString());
    logger.info(&quot;XML: &quot; + xml.toString() );
	
	var matchobx3 = false; 
	var matchobx5 = false;
	for each(rules in xml..rules)
	{
		var subName = rules.destinationaddress.toString();

    	if (subName.length &gt; 0)
	    {
      		if(subName == &quot;CANR&quot;) 
			{
				matchobx3 = true; 
			}
			else if(subName == &quot;CAN&quot;)
			{
				matchobx5 = true; 
			}
		}
	}
	
    var subName = xml.rules.destinationaddress.toString();

    if (subName.length &gt; 0)
    {
      logger.info(&quot;Subscription criteria met for subscription: &quot; + subName);
      channelMap.put(&apos;subscriptionName&apos;, subName );

      var subRuleName = xml.rules.rulename.toString();
      logger.info(&quot;Rule name: &quot; + subRuleName);

      channelMap.put(&apos;subscriptionRuleName&apos;, subRuleName );

      // Determine subscription descriptive name based on short name.  This is used
      // in email alert.
      var subscriptionDesc;
      if (subName == &quot;SAL&quot;) 
      {
        subscriptionDesc = &quot;Salmonellosis&quot;;
      }
      else if (subName == &quot;HEP&quot;)
      {
        subscriptionDesc = &quot;Hepatitis C&quot;;
      }
      else if (subName == &quot;FLU&quot;)
      {
        subscriptionDesc = &quot;Influenza&quot;;
      }  
      else if (subName == &quot;ADT&quot;)
      {
        subscriptionDesc = &quot;ADT&quot;;
      }
      else if (subName == &quot;IMM&quot;)
      {
        subscriptionDesc = &quot;Immunization&quot;;
      }
      else if (subName == &quot;DOH1&quot;)
      {
        subscriptionDesc = &quot;Electronic Test Order &amp; Result (ETOR)&quot;;
      }
	  else if (matchobx3 &amp;&amp; matchobx5)
	  {
		subscriptionDesc =  &quot;Cancer Registry&quot;;
	  }
      else 
      {
        subscriptionDesc = &quot;Unkonwn subscription: &quot; + subName;
      }
    
      channelMap.put(&apos;subscriptionDesc&apos;, subscriptionDesc );

      channelMap.put(&apos;obx51&apos;, msg[&apos;OBX&apos;][&apos;OBX.5&apos;][&apos;OBX.5.1&apos;].toString() );
      channelMap.put(&apos;obx52&apos;, msg[&apos;OBX&apos;][&apos;OBX.5&apos;][&apos;OBX.5.2&apos;].toString() );

      channelMap.put(&apos;placerOrderNumberEntityID&apos;, msg[&apos;OBR&apos;][&apos;OBR.2&apos;][&apos;OBR.2.1&apos;].toString() );                                  

      logger.info(&quot;Rule name: &quot; + subRuleName);
    }
    else
    {
      logger.info(&quot;No subscriptions for msg.&quot;);
    }
  }

}
catch(e)
{
  logger.error(&quot;Error in Process SubscriptionService Response Transformer: &quot; + e.message);
  channelMap.put(&apos;componentErrors&apos;,  $(&apos;componentErrors&apos;) + &quot;Process SubscriptionService Response Transformer:\n&quot; + e.message + &quot; |\n&quot;);
}</string>
              </entry>
            </data>
          </step>
        </steps>
        <inboundTemplate encoding="base64"></inboundTemplate>
        <outboundTemplate encoding="base64"></outboundTemplate>
        <inboundProtocol>HL7V2</inboundProtocol>
        <outboundProtocol>HL7V2</outboundProtocol>
        <inboundProperties>
          <property name="convertLFtoCR">true</property>
          <property name="handleRepetitions">false</property>
          <property name="handleSubcomponents">false</property>
          <property name="stripNamespaces">true</property>
          <property name="useStrictParser">false</property>
          <property name="useStrictValidation">false</property>
        </inboundProperties>
        <outboundProperties>
          <property name="convertLFtoCR">true</property>
          <property name="handleRepetitions">false</property>
          <property name="handleSubcomponents">false</property>
          <property name="stripNamespaces">true</property>
          <property name="useStrictParser">false</property>
          <property name="useStrictValidation">false</property>
        </outboundProperties>
      </transformer>
      <filter>
        <rules>
          <rule>
            <sequenceNumber>0</sequenceNumber>
            <name>Filter destination based on component configuration and prior errors</name>
            <data class="map">
              <entry>
                <string>Script</string>
                <string>return ($(&apos;subscription&apos;) == &apos;true&apos; &amp;&amp; 
        $(&apos;componentErrors&apos;).length() == 0 &amp;&amp;
        $(&apos;hubHost&apos;) == $(&apos;receivingFacilityHubHost&apos;));</string>
              </entry>
            </data>
            <type>JavaScript</type>
            <script>return ($(&apos;subscription&apos;) == &apos;true&apos; &amp;&amp; 
        $(&apos;componentErrors&apos;).length() == 0 &amp;&amp;
        $(&apos;hubHost&apos;) == $(&apos;receivingFacilityHubHost&apos;));</script>
            <operator>NONE</operator>
          </rule>
        </rules>
      </filter>
      <transportName>Channel Writer</transportName>
      <mode>DESTINATION</mode>
      <enabled>true</enabled>
      <version>2.2.0.5828</version>
    </connector>
    <connector>
      <name>Call BioSenseLinker</name>
      <properties>
        <property name="DataType">HTTP Sender</property>
        <property name="dispatcherAuthenticationType">Basic</property>
        <property name="dispatcherCharset">UTF-8</property>
        <property name="dispatcherContent"></property>
        <property name="dispatcherContentType">text/plain</property>
        <property name="dispatcherHeaders">&lt;properties/&gt;</property>
        <property name="dispatcherIncludeHeadersInResponse">0</property>
        <property name="dispatcherMethod">get</property>
        <property name="dispatcherMultipart">0</property>
        <property name="dispatcherParameters">&lt;properties&gt;
  &lt;property name=&quot;dsPatientAssigningAuthority&quot;&gt;${patientAssigningAuthority}&lt;/property&gt;
  &lt;property name=&quot;dsPatientId&quot;&gt;${patientID}&lt;/property&gt;
  &lt;property name=&quot;dsPatientIdType&quot;&gt;${patientIDType}&lt;/property&gt;
  &lt;property name=&quot;dsVisitAssigningAuthority&quot;&gt;${visitAssigningAuthority}&lt;/property&gt;
  &lt;property name=&quot;dsVisitId&quot;&gt;${visitID}&lt;/property&gt;
  &lt;property name=&quot;dsVisitIdType&quot;&gt;${visitIDType}&lt;/property&gt;
  &lt;property name=&quot;firstName&quot;&gt;${patientFName}&lt;/property&gt;
  &lt;property name=&quot;lastName&quot;&gt;${patientLName}&lt;/property&gt;
  &lt;property name=&quot;messageType&quot;&gt;${msgTriggerEvent}&lt;/property&gt;
  &lt;property name=&quot;middleName&quot;&gt;${patientMiddle}&lt;/property&gt;
&lt;/properties&gt;</property>
        <property name="dispatcherPassword">Admin</property>
        <property name="dispatcherReplyChannelId">sink</property>
        <property name="dispatcherSocketTimeout">30000</property>
        <property name="dispatcherUseAuthentication">1</property>
        <property name="dispatcherUsername">Admin</property>
        <property name="host">http://localhost:8500/bioSense/Identifiers</property>
        <property name="queuePollInterval">200</property>
        <property name="reconnectMillisecs">10000</property>
        <property name="rotateQueue">0</property>
        <property name="usePersistentQueues">0</property>
      </properties>
      <transformer>
        <steps>
          <step>
            <sequenceNumber>0</sequenceNumber>
            <name>Extract BioSenseLinker input parameters from message</name>
            <script>try
{
  SerializerFactory.getHL7Serializer().toXML(message);

  logger.info(&quot;BioSenseLinker&quot;);

  // &quot;messageType&quot; input parameter is actually MSH.9.2: $(&apos;msgTriggerEvent&apos;)
  logger.info(&quot;Setting patientFName=&quot; + msg[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.2&apos;].toString() );
  channelMap.put(&apos;patientFName&apos;, msg[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.2&apos;].toString() );

  logger.info(&quot;Setting patientLName=&quot; + msg[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.1&apos;].toString() );
  channelMap.put(&apos;patientLName&apos;, msg[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.1&apos;].toString() );

  logger.info(&quot;Setting patientMiddle=&quot; + msg[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.3&apos;].toString() );
  channelMap.put(&apos;patientMiddle&apos;, msg[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.3&apos;].toString() );

  logger.info(&quot;Setting patientID=&quot; + msg[&apos;PID&apos;][&apos;PID.3&apos;][&apos;PID.3.1&apos;].toString() );
  channelMap.put(&apos;patientID&apos;, msg[&apos;PID&apos;][&apos;PID.3&apos;][&apos;PID.3.1&apos;].toString() );

  logger.info(&quot;Setting patientIDType=MRN&quot;);
  channelMap.put(&apos;patientIDType&apos;, &quot;MRN&quot;);

  logger.info(&quot;Setting patientAssigningAuthority=&quot; + msg[&apos;MSH&apos;][&apos;MSH.4&apos;][&apos;MSH.4.2&apos;].toString() );
  channelMap.put(&apos;patientAssigningAuthority&apos;, msg[&apos;MSH&apos;][&apos;MSH.4&apos;][&apos;MSH.4.2&apos;].toString() );

  logger.info(&quot;Setting visitID=&quot; + msg[&apos;PV1&apos;][&apos;PV1.19&apos;][&apos;PV1.19.1&apos;].toString() );
  channelMap.put(&apos;visitID&apos;, msg[&apos;PV1&apos;][&apos;PV1.19&apos;][&apos;PV1.19.1&apos;].toString() );

  logger.info(&quot;Setting visitIDType=AN&quot;);
  channelMap.put(&apos;visitIDType&apos;, &quot;AN&quot;);

  logger.info(&quot;Setting visitAssigningAuthority=&quot; + msg[&apos;MSH&apos;][&apos;MSH.4&apos;][&apos;MSH.4.2&apos;].toString() );
  channelMap.put(&apos;visitAssigningAuthority&apos;, msg[&apos;MSH&apos;][&apos;MSH.4&apos;][&apos;MSH.4.2&apos;].toString() );
}
catch(e)
{
  logger.error(&quot;Error in Call BioSenseLinker Transformer: &quot; + e.message);
  channelMap.put(&apos;componentErrors&apos;,  $(&apos;componentErrors&apos;) + &quot;Call BioSenseLinker Transformer:\n&quot; + e.message + &quot; |\n&quot;);
}</script>
            <type>JavaScript</type>
            <data class="map">
              <entry>
                <string>Script</string>
                <string>try
{
  SerializerFactory.getHL7Serializer().toXML(message);

  logger.info(&quot;BioSenseLinker&quot;);

  // &quot;messageType&quot; input parameter is actually MSH.9.2: $(&apos;msgTriggerEvent&apos;)
  logger.info(&quot;Setting patientFName=&quot; + msg[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.2&apos;].toString() );
  channelMap.put(&apos;patientFName&apos;, msg[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.2&apos;].toString() );

  logger.info(&quot;Setting patientLName=&quot; + msg[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.1&apos;].toString() );
  channelMap.put(&apos;patientLName&apos;, msg[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.1&apos;].toString() );

  logger.info(&quot;Setting patientMiddle=&quot; + msg[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.3&apos;].toString() );
  channelMap.put(&apos;patientMiddle&apos;, msg[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.3&apos;].toString() );

  logger.info(&quot;Setting patientID=&quot; + msg[&apos;PID&apos;][&apos;PID.3&apos;][&apos;PID.3.1&apos;].toString() );
  channelMap.put(&apos;patientID&apos;, msg[&apos;PID&apos;][&apos;PID.3&apos;][&apos;PID.3.1&apos;].toString() );

  logger.info(&quot;Setting patientIDType=MRN&quot;);
  channelMap.put(&apos;patientIDType&apos;, &quot;MRN&quot;);

  logger.info(&quot;Setting patientAssigningAuthority=&quot; + msg[&apos;MSH&apos;][&apos;MSH.4&apos;][&apos;MSH.4.2&apos;].toString() );
  channelMap.put(&apos;patientAssigningAuthority&apos;, msg[&apos;MSH&apos;][&apos;MSH.4&apos;][&apos;MSH.4.2&apos;].toString() );

  logger.info(&quot;Setting visitID=&quot; + msg[&apos;PV1&apos;][&apos;PV1.19&apos;][&apos;PV1.19.1&apos;].toString() );
  channelMap.put(&apos;visitID&apos;, msg[&apos;PV1&apos;][&apos;PV1.19&apos;][&apos;PV1.19.1&apos;].toString() );

  logger.info(&quot;Setting visitIDType=AN&quot;);
  channelMap.put(&apos;visitIDType&apos;, &quot;AN&quot;);

  logger.info(&quot;Setting visitAssigningAuthority=&quot; + msg[&apos;MSH&apos;][&apos;MSH.4&apos;][&apos;MSH.4.2&apos;].toString() );
  channelMap.put(&apos;visitAssigningAuthority&apos;, msg[&apos;MSH&apos;][&apos;MSH.4&apos;][&apos;MSH.4.2&apos;].toString() );
}
catch(e)
{
  logger.error(&quot;Error in Call BioSenseLinker Transformer: &quot; + e.message);
  channelMap.put(&apos;componentErrors&apos;,  $(&apos;componentErrors&apos;) + &quot;Call BioSenseLinker Transformer:\n&quot; + e.message + &quot; |\n&quot;);
}</string>
              </entry>
            </data>
          </step>
        </steps>
        <inboundTemplate encoding="base64"></inboundTemplate>
        <outboundTemplate encoding="base64"></outboundTemplate>
        <inboundProtocol>HL7V2</inboundProtocol>
        <outboundProtocol>HL7V2</outboundProtocol>
        <inboundProperties>
          <property name="convertLFtoCR">true</property>
          <property name="handleRepetitions">false</property>
          <property name="handleSubcomponents">false</property>
          <property name="stripNamespaces">true</property>
          <property name="useStrictParser">false</property>
          <property name="useStrictValidation">false</property>
        </inboundProperties>
        <outboundProperties>
          <property name="convertLFtoCR">true</property>
          <property name="handleRepetitions">false</property>
          <property name="handleSubcomponents">false</property>
          <property name="stripNamespaces">true</property>
          <property name="useStrictParser">false</property>
          <property name="useStrictValidation">false</property>
        </outboundProperties>
      </transformer>
      <filter>
        <rules>
          <rule>
            <sequenceNumber>0</sequenceNumber>
            <name>Filter call to BioSenseLinker based on ComponentRoutingService configuration</name>
            <data class="map">
              <entry>
                <string>Script</string>
                <string>var retval = false;

if ($(&apos;anonymization&apos;) != &apos;true&apos;)
{
  logger.info(&quot;Bypassing BioSenseLinker call based on component routing configuration&quot;);
}
// unlike prior components, Linker anonymization takes place at sending facility
else if ($(&apos;hubHost&apos;) != $(&apos;sendingFacilityHubHost&apos;))
{
  logger.info(&quot;Bypassing BioSenseLinker since msg is not at Sending Facility&quot;);
}
else if ($(&apos;componentErrors&apos;).length() &gt; 0)
{
  logger.info(&quot;Bypassing BioSenseLinker call because of prior errors: &quot; + $(&apos;componentErrors&apos;));
}
else
{
  logger.info(&quot;Calling BioSenseLinker to perform anonymization&quot;);
  retval = true;
}

if (retval)
{
  channelMap.put(&apos;anonymizationCallStatus&apos;, &apos;CALLED&apos;);
}
else
{
  channelMap.put(&apos;anonymizationCallStatus&apos;, &apos;BYPASSED&apos;);
}

return retval;</string>
              </entry>
            </data>
            <type>JavaScript</type>
            <script>var retval = false;

if ($(&apos;anonymization&apos;) != &apos;true&apos;)
{
  logger.info(&quot;Bypassing BioSenseLinker call based on component routing configuration&quot;);
}
// unlike prior components, Linker anonymization takes place at sending facility
else if ($(&apos;hubHost&apos;) != $(&apos;sendingFacilityHubHost&apos;))
{
  logger.info(&quot;Bypassing BioSenseLinker since msg is not at Sending Facility&quot;);
}
else if ($(&apos;componentErrors&apos;).length() &gt; 0)
{
  logger.info(&quot;Bypassing BioSenseLinker call because of prior errors: &quot; + $(&apos;componentErrors&apos;));
}
else
{
  logger.info(&quot;Calling BioSenseLinker to perform anonymization&quot;);
  retval = true;
}

if (retval)
{
  channelMap.put(&apos;anonymizationCallStatus&apos;, &apos;CALLED&apos;);
}
else
{
  channelMap.put(&apos;anonymizationCallStatus&apos;, &apos;BYPASSED&apos;);
}

return retval;</script>
            <operator>NONE</operator>
          </rule>
        </rules>
      </filter>
      <transportName>HTTP Sender</transportName>
      <mode>DESTINATION</mode>
      <enabled>true</enabled>
      <version>2.2.0.5828</version>
    </connector>
    <connector>
      <name>Process BioSenseLinker Response</name>
      <properties>
        <property name="DataType">Channel Writer</property>
        <property name="host">sink</property>
        <property name="synchronised">0</property>
        <property name="template">${message.encodedData}</property>
      </properties>
      <transformer>
        <steps>
          <step>
            <sequenceNumber>0</sequenceNumber>
            <name>process BioSenseLinker HTTP response</name>
            <script>try
{
  var resp = new XML(responseMap.get(&apos;Call BioSenseLinker&apos;).getMessage());

  // If resp..*::sBioSensePatientId is not present in response XML, an error likely occurred during the service call.
  // Record the response to the componentErrors variable and don&apos;t attempt to parse results.
  if (undefined == resp..*::[&apos;sBioSensePatientId&apos;])
  {
    logger.error(&quot;No sBioSensePatientId element found in BioSenseLinker response. Recording response to componentErrors variable: &quot; + resp);
    channelMap.put(&apos;componentErrors&apos;,  $(&apos;componentErrors&apos;) + &quot;BioSenseLinker:\n&quot; + resp + &quot; |\n&quot;);
  }
  else
  {
    logger.info(&quot;Processing BioSenseLinker response&quot;);
    logger.info(resp);

    var xml = new XML(resp);

    logger.info(&quot;bioSensePatientId=&quot; + xml[&apos;sBioSensePatientId&apos;]);
    logger.info(&quot;bioSenseVisitId=&quot; + xml[&apos;sBioSenseVisitId&apos;]);

    channelMap.put(&apos;bioSensePatientId&apos;, xml[&apos;sBioSensePatientId&apos;]);
    channelMap.put(&apos;bioSenseVisitId&apos;, xml[&apos;sBioSenseVisitId&apos;]);
  }
}
catch(e)
{
  logger.error(&quot;Error in Process BioSenseLinker Response Transformer: &quot; + e.message);
  channelMap.put(&apos;componentErrors&apos;,  $(&apos;componentErrors&apos;) + &quot;Process BioSenseLinker Response Transformer:\n&quot; + e.message + &quot; |\n&quot;);
}</script>
            <type>JavaScript</type>
            <data class="map">
              <entry>
                <string>Script</string>
                <string>try
{
  var resp = new XML(responseMap.get(&apos;Call BioSenseLinker&apos;).getMessage());

  // If resp..*::sBioSensePatientId is not present in response XML, an error likely occurred during the service call.
  // Record the response to the componentErrors variable and don&apos;t attempt to parse results.
  if (undefined == resp..*::[&apos;sBioSensePatientId&apos;])
  {
    logger.error(&quot;No sBioSensePatientId element found in BioSenseLinker response. Recording response to componentErrors variable: &quot; + resp);
    channelMap.put(&apos;componentErrors&apos;,  $(&apos;componentErrors&apos;) + &quot;BioSenseLinker:\n&quot; + resp + &quot; |\n&quot;);
  }
  else
  {
    logger.info(&quot;Processing BioSenseLinker response&quot;);
    logger.info(resp);

    var xml = new XML(resp);

    logger.info(&quot;bioSensePatientId=&quot; + xml[&apos;sBioSensePatientId&apos;]);
    logger.info(&quot;bioSenseVisitId=&quot; + xml[&apos;sBioSenseVisitId&apos;]);

    channelMap.put(&apos;bioSensePatientId&apos;, xml[&apos;sBioSensePatientId&apos;]);
    channelMap.put(&apos;bioSenseVisitId&apos;, xml[&apos;sBioSenseVisitId&apos;]);
  }
}
catch(e)
{
  logger.error(&quot;Error in Process BioSenseLinker Response Transformer: &quot; + e.message);
  channelMap.put(&apos;componentErrors&apos;,  $(&apos;componentErrors&apos;) + &quot;Process BioSenseLinker Response Transformer:\n&quot; + e.message + &quot; |\n&quot;);
}</string>
              </entry>
            </data>
          </step>
        </steps>
        <inboundTemplate encoding="base64"></inboundTemplate>
        <outboundTemplate encoding="base64"></outboundTemplate>
        <inboundProtocol>HL7V2</inboundProtocol>
        <outboundProtocol>HL7V2</outboundProtocol>
        <inboundProperties>
          <property name="convertLFtoCR">true</property>
          <property name="handleRepetitions">false</property>
          <property name="handleSubcomponents">false</property>
          <property name="stripNamespaces">true</property>
          <property name="useStrictParser">false</property>
          <property name="useStrictValidation">false</property>
        </inboundProperties>
        <outboundProperties>
          <property name="convertLFtoCR">true</property>
          <property name="handleRepetitions">false</property>
          <property name="handleSubcomponents">false</property>
          <property name="stripNamespaces">true</property>
          <property name="useStrictParser">false</property>
          <property name="useStrictValidation">false</property>
        </outboundProperties>
      </transformer>
      <filter>
        <rules>
          <rule>
            <sequenceNumber>0</sequenceNumber>
            <name>filter processing of BioSenseLinker response</name>
            <data class="map">
              <entry>
                <string>Script</string>
                <string>return ($(&apos;anonymization&apos;) == &apos;true&apos; &amp;&amp; 
        $(&apos;componentErrors&apos;).length() == 0 &amp;&amp;
        $(&apos;hubHost&apos;) == $(&apos;sendingFacilityHubHost&apos;));</string>
              </entry>
            </data>
            <type>JavaScript</type>
            <script>return ($(&apos;anonymization&apos;) == &apos;true&apos; &amp;&amp; 
        $(&apos;componentErrors&apos;).length() == 0 &amp;&amp;
        $(&apos;hubHost&apos;) == $(&apos;sendingFacilityHubHost&apos;));</script>
            <operator>NONE</operator>
          </rule>
        </rules>
      </filter>
      <transportName>Channel Writer</transportName>
      <mode>DESTINATION</mode>
      <enabled>true</enabled>
      <version>2.2.0.5828</version>
    </connector>
    <connector>
      <name>Send ACK msg (to PHIX1)</name>
      <properties>
        <property name="DataType">Web Service Sender</property>
        <property name="dispatcherAttachmentContents">&lt;list/&gt;</property>
        <property name="dispatcherAttachmentNames">&lt;list/&gt;</property>
        <property name="dispatcherAttachmentTypes">&lt;list/&gt;</property>
        <property name="dispatcherEnvelope">&lt;soapenv:Envelope xmlns:ns=&quot;http://ws.connectors.connect.mirth.com/&quot; xmlns:soapenv=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;&gt;&#xd;
  &lt;soapenv:Header/&gt;&#xd;
  &lt;soapenv:Body&gt;&#xd;
    &lt;ns:acceptMessage&gt;&#xd;
      &lt;arg0&gt;&lt;![CDATA[${message.encodedData}]]&gt;&lt;/arg0&gt;
    &lt;/ns:acceptMessage&gt;&#xd;
  &lt;/soapenv:Body&gt;
&lt;/soapenv:Envelope&gt;&#xd;
</property>
        <property name="dispatcherOneWay">0</property>
        <property name="dispatcherOperation">acceptMessage</property>
        <property name="dispatcherPassword"></property>
        <property name="dispatcherPort">{http://ws.connectors.connect.mirth.com/}DefaultAcceptMessagePort</property>
        <property name="dispatcherReplyChannelId">sink</property>
        <property name="dispatcherService">{http://ws.connectors.connect.mirth.com/}DefaultAcceptMessageService</property>
        <property name="dispatcherSoapAction"></property>
        <property name="dispatcherUseAuthentication">0</property>
        <property name="dispatcherUseMtom">0</property>
        <property name="dispatcherUsername"></property>
        <property name="dispatcherWsdlCacheId"></property>
        <property name="dispatcherWsdlOperations">&lt;list&gt;
  &lt;string&gt;acceptMessage&lt;/string&gt;
&lt;/list&gt;</property>
        <property name="dispatcherWsdlUrl">http://phix1.phiresearchlab.org:8081/services/Mirth?wsdl</property>
        <property name="host">phix1.phiresearchlab.org:8081/services/Mirth?wsdl</property>
        <property name="queuePollInterval">200</property>
        <property name="reconnectMillisecs">10000</property>
        <property name="rotateQueue">0</property>
        <property name="usePersistentQueues">0</property>
      </properties>
      <transformer>
        <steps>
          <step>
            <sequenceNumber>0</sequenceNumber>
            <name>transform OML msg into ACK msg</name>
            <script>try
{
  // build new ACK msg out of incoming OML msg

  // delete non-MSH OML segments
  for each (seg in msg.children() )
  {
    //logger.info(&quot;DEBUG: SEG &quot; + seg.name().toString() );
    if (seg.name().toString() != &apos;MSH&apos;)
    {
      //logger.info(&quot;DEBUG: Deleting SEG &quot; + seg.name().toString() );
      delete msg[seg.name().toString()];
    }
  }

  // Obtain orig sender &amp; receiver values from OML header. 
  var omlSendingAppNSID = msg[&apos;MSH&apos;][&apos;MSH.3&apos;][&apos;MSH.3.1&apos;];
  var omlSendingAppUID = msg[&apos;MSH&apos;][&apos;MSH.3&apos;][&apos;MSH.3.2&apos;];
  var omlSendingAppUIDType = msg[&apos;MSH&apos;][&apos;MSH.3&apos;][&apos;MSH.3.3&apos;];

  var omlSendingFacNSID = msg[&apos;MSH&apos;][&apos;MSH.4&apos;][&apos;MSH.4.1&apos;];
  var omlSendingFacUID = msg[&apos;MSH&apos;][&apos;MSH.4&apos;][&apos;MSH.4.2&apos;];
  var omlSendingFacUIDType = msg[&apos;MSH&apos;][&apos;MSH.4&apos;][&apos;MSH.4.3&apos;];

  var omlRecvAppNSID = msg[&apos;MSH&apos;][&apos;MSH.5&apos;][&apos;MSH.5.1&apos;];
  var omlRecvAppUID = msg[&apos;MSH&apos;][&apos;MSH.5&apos;][&apos;MSH.5.2&apos;];
  var omlRecvAppUIDType = msg[&apos;MSH&apos;][&apos;MSH.5&apos;][&apos;MSH.5.3&apos;];

  var omlRecvFacNSID = msg[&apos;MSH&apos;][&apos;MSH.6&apos;][&apos;MSH.6.1&apos;];
  var omlRecvFacUID = msg[&apos;MSH&apos;][&apos;MSH.6&apos;][&apos;MSH.6.2&apos;];
  var omlRecvFacUIDType = msg[&apos;MSH&apos;][&apos;MSH.6&apos;][&apos;MSH.6.3&apos;];

  var omlCtrlID = msg[&apos;MSH&apos;][&apos;MSH.10&apos;][&apos;MSH.10.1&apos;];

  // Alter MSH contents with ACK-specific contents: Reverse sender and receiver.
  msg[&apos;MSH&apos;][&apos;MSH.3&apos;][&apos;MSH.3.1&apos;] = omlRecvAppNSID;
  msg[&apos;MSH&apos;][&apos;MSH.3&apos;][&apos;MSH.3.2&apos;] = omlRecvAppUID;
  msg[&apos;MSH&apos;][&apos;MSH.3&apos;][&apos;MSH.3.3&apos;] = omlRecvAppUIDType;

  msg[&apos;MSH&apos;][&apos;MSH.4&apos;][&apos;MSH.4.1&apos;] = omlRecvFacNSID;
  msg[&apos;MSH&apos;][&apos;MSH.4&apos;][&apos;MSH.4.2&apos;] = omlRecvFacUID;
  msg[&apos;MSH&apos;][&apos;MSH.4&apos;][&apos;MSH.4.3&apos;] = omlRecvFacUIDType;

  msg[&apos;MSH&apos;][&apos;MSH.5&apos;][&apos;MSH.5.1&apos;] = omlSendingAppNSID;
  msg[&apos;MSH&apos;][&apos;MSH.5&apos;][&apos;MSH.5.2&apos;] = omlSendingAppUID;
  msg[&apos;MSH&apos;][&apos;MSH.5&apos;][&apos;MSH.5.3&apos;] = omlSendingAppUIDType;

  msg[&apos;MSH&apos;][&apos;MSH.6&apos;][&apos;MSH.6.1&apos;] = omlSendingFacNSID;
  msg[&apos;MSH&apos;][&apos;MSH.6&apos;][&apos;MSH.6.2&apos;] = omlSendingFacUID;
  msg[&apos;MSH&apos;][&apos;MSH.6&apos;][&apos;MSH.6.3&apos;] = omlSendingFacUIDType;

  var curDateStamp = DateUtil.getCurrentDate(&quot;yyyyMMddHHmmss&quot;); //e.g, 20110623093000
  msg[&apos;MSH&apos;][&apos;MSH.7&apos;] = curDateStamp;
  msg[&apos;MSH&apos;][&apos;MSH.9&apos;] = &quot;ACK^O33^ACK&quot;;
  msg[&apos;MSH&apos;][&apos;MSH.10&apos;] = &quot;2.16.840.1.114222.4.3.2.5.2.7001.&quot; + curDateStamp + &quot;.0000&quot;;

  // add MSA segment
  createSegmentAfter(&apos;MSA&apos;, msg[&apos;MSH&apos;]);
  msg[&apos;MSA&apos;][&apos;MSA.1&apos;] = &quot;AA&quot;;
  msg[&apos;MSA&apos;][&apos;MSA.2&apos;] = omlCtrlID;

}
catch(e)
{
  logger.error(&quot;Error in Send ACK msg Transformer: &quot; + e.message);
  channelMap.put(&apos;componentErrors&apos;,  $(&apos;componentErrors&apos;) + &quot;Send ACK msg Transformer:\n&quot; + e.message + &quot; |\n&quot;);
}</script>
            <type>JavaScript</type>
            <data class="map">
              <entry>
                <string>Script</string>
                <string>try
{
  // build new ACK msg out of incoming OML msg

  // delete non-MSH OML segments
  for each (seg in msg.children() )
  {
    //logger.info(&quot;DEBUG: SEG &quot; + seg.name().toString() );
    if (seg.name().toString() != &apos;MSH&apos;)
    {
      //logger.info(&quot;DEBUG: Deleting SEG &quot; + seg.name().toString() );
      delete msg[seg.name().toString()];
    }
  }

  // Obtain orig sender &amp; receiver values from OML header. 
  var omlSendingAppNSID = msg[&apos;MSH&apos;][&apos;MSH.3&apos;][&apos;MSH.3.1&apos;];
  var omlSendingAppUID = msg[&apos;MSH&apos;][&apos;MSH.3&apos;][&apos;MSH.3.2&apos;];
  var omlSendingAppUIDType = msg[&apos;MSH&apos;][&apos;MSH.3&apos;][&apos;MSH.3.3&apos;];

  var omlSendingFacNSID = msg[&apos;MSH&apos;][&apos;MSH.4&apos;][&apos;MSH.4.1&apos;];
  var omlSendingFacUID = msg[&apos;MSH&apos;][&apos;MSH.4&apos;][&apos;MSH.4.2&apos;];
  var omlSendingFacUIDType = msg[&apos;MSH&apos;][&apos;MSH.4&apos;][&apos;MSH.4.3&apos;];

  var omlRecvAppNSID = msg[&apos;MSH&apos;][&apos;MSH.5&apos;][&apos;MSH.5.1&apos;];
  var omlRecvAppUID = msg[&apos;MSH&apos;][&apos;MSH.5&apos;][&apos;MSH.5.2&apos;];
  var omlRecvAppUIDType = msg[&apos;MSH&apos;][&apos;MSH.5&apos;][&apos;MSH.5.3&apos;];

  var omlRecvFacNSID = msg[&apos;MSH&apos;][&apos;MSH.6&apos;][&apos;MSH.6.1&apos;];
  var omlRecvFacUID = msg[&apos;MSH&apos;][&apos;MSH.6&apos;][&apos;MSH.6.2&apos;];
  var omlRecvFacUIDType = msg[&apos;MSH&apos;][&apos;MSH.6&apos;][&apos;MSH.6.3&apos;];

  var omlCtrlID = msg[&apos;MSH&apos;][&apos;MSH.10&apos;][&apos;MSH.10.1&apos;];

  // Alter MSH contents with ACK-specific contents: Reverse sender and receiver.
  msg[&apos;MSH&apos;][&apos;MSH.3&apos;][&apos;MSH.3.1&apos;] = omlRecvAppNSID;
  msg[&apos;MSH&apos;][&apos;MSH.3&apos;][&apos;MSH.3.2&apos;] = omlRecvAppUID;
  msg[&apos;MSH&apos;][&apos;MSH.3&apos;][&apos;MSH.3.3&apos;] = omlRecvAppUIDType;

  msg[&apos;MSH&apos;][&apos;MSH.4&apos;][&apos;MSH.4.1&apos;] = omlRecvFacNSID;
  msg[&apos;MSH&apos;][&apos;MSH.4&apos;][&apos;MSH.4.2&apos;] = omlRecvFacUID;
  msg[&apos;MSH&apos;][&apos;MSH.4&apos;][&apos;MSH.4.3&apos;] = omlRecvFacUIDType;

  msg[&apos;MSH&apos;][&apos;MSH.5&apos;][&apos;MSH.5.1&apos;] = omlSendingAppNSID;
  msg[&apos;MSH&apos;][&apos;MSH.5&apos;][&apos;MSH.5.2&apos;] = omlSendingAppUID;
  msg[&apos;MSH&apos;][&apos;MSH.5&apos;][&apos;MSH.5.3&apos;] = omlSendingAppUIDType;

  msg[&apos;MSH&apos;][&apos;MSH.6&apos;][&apos;MSH.6.1&apos;] = omlSendingFacNSID;
  msg[&apos;MSH&apos;][&apos;MSH.6&apos;][&apos;MSH.6.2&apos;] = omlSendingFacUID;
  msg[&apos;MSH&apos;][&apos;MSH.6&apos;][&apos;MSH.6.3&apos;] = omlSendingFacUIDType;

  var curDateStamp = DateUtil.getCurrentDate(&quot;yyyyMMddHHmmss&quot;); //e.g, 20110623093000
  msg[&apos;MSH&apos;][&apos;MSH.7&apos;] = curDateStamp;
  msg[&apos;MSH&apos;][&apos;MSH.9&apos;] = &quot;ACK^O33^ACK&quot;;
  msg[&apos;MSH&apos;][&apos;MSH.10&apos;] = &quot;2.16.840.1.114222.4.3.2.5.2.7001.&quot; + curDateStamp + &quot;.0000&quot;;

  // add MSA segment
  createSegmentAfter(&apos;MSA&apos;, msg[&apos;MSH&apos;]);
  msg[&apos;MSA&apos;][&apos;MSA.1&apos;] = &quot;AA&quot;;
  msg[&apos;MSA&apos;][&apos;MSA.2&apos;] = omlCtrlID;

}
catch(e)
{
  logger.error(&quot;Error in Send ACK msg Transformer: &quot; + e.message);
  channelMap.put(&apos;componentErrors&apos;,  $(&apos;componentErrors&apos;) + &quot;Send ACK msg Transformer:\n&quot; + e.message + &quot; |\n&quot;);
}</string>
              </entry>
            </data>
          </step>
        </steps>
        <inboundTemplate encoding="base64"></inboundTemplate>
        <outboundTemplate encoding="base64"></outboundTemplate>
        <inboundProtocol>HL7V2</inboundProtocol>
        <outboundProtocol>HL7V2</outboundProtocol>
        <inboundProperties>
          <property name="convertLFtoCR">true</property>
          <property name="handleRepetitions">false</property>
          <property name="handleSubcomponents">false</property>
          <property name="stripNamespaces">true</property>
          <property name="useStrictParser">false</property>
          <property name="useStrictValidation">false</property>
        </inboundProperties>
        <outboundProperties>
          <property name="convertLFtoCR">true</property>
          <property name="handleRepetitions">false</property>
          <property name="handleSubcomponents">false</property>
          <property name="stripNamespaces">true</property>
          <property name="useStrictParser">false</property>
          <property name="useStrictValidation">false</property>
        </outboundProperties>
      </transformer>
      <filter>
        <rules>
          <rule>
            <sequenceNumber>0</sequenceNumber>
            <name>filter for 2.6 OML_O33 and MIRTH_WS xport</name>
            <data class="map">
              <entry>
                <string>Script</string>
                <string>var retval = false;

// Unfortunately, this version of Mirth does not seem to support variables inside web service endpoint URLs.
// This outermost conditional filters for phix1.phiresearchlab.org:8081 (PHIX 1) specifically (shouldn&apos;t be necessary).
if ($(&apos;sendingFacilityWebSvcHost&apos;) == &apos;phix1.phiresearchlab.org:8081&apos;)
{

  if ($(&apos;sendingFacilityXportType&apos;) == &apos;MIRTH_WS&apos; &amp;&amp;
      $(&apos;msgType&apos;) == &apos;OML&apos; &amp;&amp;
      $(&apos;msgTriggerEvent&apos;) == &apos;O33&apos; &amp;&amp;
      $(&apos;msgHL7VersionID&apos;) == &apos;2.6&apos; &amp;&amp;
      $(&apos;hubHost&apos;) == $(&apos;receivingFacilityHubHost&apos;))
  {
    if ($(&apos;componentErrors&apos;).length() &gt; 0)
    {
      logger.info(&quot;Bypassing Send ACK because of prior errors: &quot; + $(&apos;componentErrors&apos;));
    }
    else
    {
      logger.info(&quot;Received an 2.6 OML O33 msg. Sending ACK back to original Sending Facility over Mirth WS.&quot;);
      retval = true;
    }
  }

}

if (retval)
{
  channelMap.put(&apos;ackSentStatus&apos;, &apos;SENT VIA WS&apos;);
}
else
{
  channelMap.put(&apos;ackSentStatus&apos;, &apos;BYPASSED&apos;);
}


return retval;</string>
              </entry>
            </data>
            <type>JavaScript</type>
            <script>var retval = false;

// Unfortunately, this version of Mirth does not seem to support variables inside web service endpoint URLs.
// This outermost conditional filters for phix1.phiresearchlab.org:8081 (PHIX 1) specifically (shouldn&apos;t be necessary).
if ($(&apos;sendingFacilityWebSvcHost&apos;) == &apos;phix1.phiresearchlab.org:8081&apos;)
{

  if ($(&apos;sendingFacilityXportType&apos;) == &apos;MIRTH_WS&apos; &amp;&amp;
      $(&apos;msgType&apos;) == &apos;OML&apos; &amp;&amp;
      $(&apos;msgTriggerEvent&apos;) == &apos;O33&apos; &amp;&amp;
      $(&apos;msgHL7VersionID&apos;) == &apos;2.6&apos; &amp;&amp;
      $(&apos;hubHost&apos;) == $(&apos;receivingFacilityHubHost&apos;))
  {
    if ($(&apos;componentErrors&apos;).length() &gt; 0)
    {
      logger.info(&quot;Bypassing Send ACK because of prior errors: &quot; + $(&apos;componentErrors&apos;));
    }
    else
    {
      logger.info(&quot;Received an 2.6 OML O33 msg. Sending ACK back to original Sending Facility over Mirth WS.&quot;);
      retval = true;
    }
  }

}

if (retval)
{
  channelMap.put(&apos;ackSentStatus&apos;, &apos;SENT VIA WS&apos;);
}
else
{
  channelMap.put(&apos;ackSentStatus&apos;, &apos;BYPASSED&apos;);
}


return retval;</script>
            <operator>NONE</operator>
          </rule>
        </rules>
      </filter>
      <transportName>Web Service Sender</transportName>
      <mode>DESTINATION</mode>
      <enabled>false</enabled>
      <version>2.2.0.5828</version>
    </connector>
    <connector>
      <name>Send ACK msg (to PHIX2)</name>
      <properties>
        <property name="DataType">Web Service Sender</property>
        <property name="dispatcherAttachmentContents">&lt;list/&gt;</property>
        <property name="dispatcherAttachmentNames">&lt;list/&gt;</property>
        <property name="dispatcherAttachmentTypes">&lt;list/&gt;</property>
        <property name="dispatcherEnvelope">&lt;soapenv:Envelope xmlns:ns=&quot;http://ws.connectors.connect.mirth.com/&quot; xmlns:soapenv=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;&gt;&#xd;
  &lt;soapenv:Header/&gt;&#xd;
  &lt;soapenv:Body&gt;&#xd;
    &lt;ns:acceptMessage&gt;&#xd;
      &lt;arg0&gt;&lt;![CDATA[${message.encodedData}]]&gt;&lt;/arg0&gt;
    &lt;/ns:acceptMessage&gt;&#xd;
  &lt;/soapenv:Body&gt;
&lt;/soapenv:Envelope&gt;&#xd;
</property>
        <property name="dispatcherOneWay">0</property>
        <property name="dispatcherOperation">acceptMessage</property>
        <property name="dispatcherPassword"></property>
        <property name="dispatcherPort">{http://ws.connectors.connect.mirth.com/}DefaultAcceptMessagePort</property>
        <property name="dispatcherReplyChannelId">sink</property>
        <property name="dispatcherService">{http://ws.connectors.connect.mirth.com/}DefaultAcceptMessageService</property>
        <property name="dispatcherSoapAction"></property>
        <property name="dispatcherUseAuthentication">0</property>
        <property name="dispatcherUseMtom">0</property>
        <property name="dispatcherUsername"></property>
        <property name="dispatcherWsdlCacheId"></property>
        <property name="dispatcherWsdlOperations">&lt;list&gt;
  &lt;string&gt;acceptMessage&lt;/string&gt;
&lt;/list&gt;</property>
        <property name="dispatcherWsdlUrl">http://phix2.phiresearchlab.org:8081/services/Mirth?wsdl</property>
        <property name="host">phix2.phiresearchlab.org:8081/services/Mirth?wsdl</property>
        <property name="queuePollInterval">200</property>
        <property name="reconnectMillisecs">10000</property>
        <property name="rotateQueue">0</property>
        <property name="usePersistentQueues">0</property>
      </properties>
      <transformer>
        <steps>
          <step>
            <sequenceNumber>0</sequenceNumber>
            <name>transform OML msg into ACK msg</name>
            <script>try
{
  // build new ACK msg out of incoming OML msg

  // delete non-MSH OML segments
  for each (seg in msg.children() )
  {
    //logger.info(&quot;DEBUG: SEG &quot; + seg.name().toString() );
    if (seg.name().toString() != &apos;MSH&apos;)
    {
      //logger.info(&quot;DEBUG: Deleting SEG &quot; + seg.name().toString() );
      delete msg[seg.name().toString()];
    }
  }

  // Obtain orig sender &amp; receiver values from OML header. 
  var omlSendingAppNSID = msg[&apos;MSH&apos;][&apos;MSH.3&apos;][&apos;MSH.3.1&apos;];
  var omlSendingAppUID = msg[&apos;MSH&apos;][&apos;MSH.3&apos;][&apos;MSH.3.2&apos;];
  var omlSendingAppUIDType = msg[&apos;MSH&apos;][&apos;MSH.3&apos;][&apos;MSH.3.3&apos;];

  var omlSendingFacNSID = msg[&apos;MSH&apos;][&apos;MSH.4&apos;][&apos;MSH.4.1&apos;];
  var omlSendingFacUID = msg[&apos;MSH&apos;][&apos;MSH.4&apos;][&apos;MSH.4.2&apos;];
  var omlSendingFacUIDType = msg[&apos;MSH&apos;][&apos;MSH.4&apos;][&apos;MSH.4.3&apos;];

  var omlRecvAppNSID = msg[&apos;MSH&apos;][&apos;MSH.5&apos;][&apos;MSH.5.1&apos;];
  var omlRecvAppUID = msg[&apos;MSH&apos;][&apos;MSH.5&apos;][&apos;MSH.5.2&apos;];
  var omlRecvAppUIDType = msg[&apos;MSH&apos;][&apos;MSH.5&apos;][&apos;MSH.5.3&apos;];

  var omlRecvFacNSID = msg[&apos;MSH&apos;][&apos;MSH.6&apos;][&apos;MSH.6.1&apos;];
  var omlRecvFacUID = msg[&apos;MSH&apos;][&apos;MSH.6&apos;][&apos;MSH.6.2&apos;];
  var omlRecvFacUIDType = msg[&apos;MSH&apos;][&apos;MSH.6&apos;][&apos;MSH.6.3&apos;];

  var omlCtrlID = msg[&apos;MSH&apos;][&apos;MSH.10&apos;][&apos;MSH.10.1&apos;];

  // Alter MSH contents with ACK-specific contents: Reverse sender and receiver.
  msg[&apos;MSH&apos;][&apos;MSH.3&apos;][&apos;MSH.3.1&apos;] = omlRecvAppNSID;
  msg[&apos;MSH&apos;][&apos;MSH.3&apos;][&apos;MSH.3.2&apos;] = omlRecvAppUID;
  msg[&apos;MSH&apos;][&apos;MSH.3&apos;][&apos;MSH.3.3&apos;] = omlRecvAppUIDType;

  msg[&apos;MSH&apos;][&apos;MSH.4&apos;][&apos;MSH.4.1&apos;] = omlRecvFacNSID;
  msg[&apos;MSH&apos;][&apos;MSH.4&apos;][&apos;MSH.4.2&apos;] = omlRecvFacUID;
  msg[&apos;MSH&apos;][&apos;MSH.4&apos;][&apos;MSH.4.3&apos;] = omlRecvFacUIDType;

  msg[&apos;MSH&apos;][&apos;MSH.5&apos;][&apos;MSH.5.1&apos;] = omlSendingAppNSID;
  msg[&apos;MSH&apos;][&apos;MSH.5&apos;][&apos;MSH.5.2&apos;] = omlSendingAppUID;
  msg[&apos;MSH&apos;][&apos;MSH.5&apos;][&apos;MSH.5.3&apos;] = omlSendingAppUIDType;

  msg[&apos;MSH&apos;][&apos;MSH.6&apos;][&apos;MSH.6.1&apos;] = omlSendingFacNSID;
  msg[&apos;MSH&apos;][&apos;MSH.6&apos;][&apos;MSH.6.2&apos;] = omlSendingFacUID;
  msg[&apos;MSH&apos;][&apos;MSH.6&apos;][&apos;MSH.6.3&apos;] = omlSendingFacUIDType;

  var curDateStamp = DateUtil.getCurrentDate(&quot;yyyyMMddHHmmss&quot;); //e.g, 20110623093000
  msg[&apos;MSH&apos;][&apos;MSH.7&apos;] = curDateStamp;
  msg[&apos;MSH&apos;][&apos;MSH.9&apos;] = &quot;ACK^O33^ACK&quot;;
  msg[&apos;MSH&apos;][&apos;MSH.10&apos;] = &quot;2.16.840.1.114222.4.3.2.5.2.7001.&quot; + curDateStamp + &quot;.0000&quot;;

  // add MSA segment
  createSegmentAfter(&apos;MSA&apos;, msg[&apos;MSH&apos;]);
  msg[&apos;MSA&apos;][&apos;MSA.1&apos;] = &quot;AA&quot;;
  msg[&apos;MSA&apos;][&apos;MSA.2&apos;] = omlCtrlID;

}
catch(e)
{
  logger.error(&quot;Error in Send ACK msg Transformer: &quot; + e.message);
  channelMap.put(&apos;componentErrors&apos;,  $(&apos;componentErrors&apos;) + &quot;Send ACK msg Transformer:\n&quot; + e.message + &quot; |\n&quot;);
}</script>
            <type>JavaScript</type>
            <data class="map">
              <entry>
                <string>Script</string>
                <string>try
{
  // build new ACK msg out of incoming OML msg

  // delete non-MSH OML segments
  for each (seg in msg.children() )
  {
    //logger.info(&quot;DEBUG: SEG &quot; + seg.name().toString() );
    if (seg.name().toString() != &apos;MSH&apos;)
    {
      //logger.info(&quot;DEBUG: Deleting SEG &quot; + seg.name().toString() );
      delete msg[seg.name().toString()];
    }
  }

  // Obtain orig sender &amp; receiver values from OML header. 
  var omlSendingAppNSID = msg[&apos;MSH&apos;][&apos;MSH.3&apos;][&apos;MSH.3.1&apos;];
  var omlSendingAppUID = msg[&apos;MSH&apos;][&apos;MSH.3&apos;][&apos;MSH.3.2&apos;];
  var omlSendingAppUIDType = msg[&apos;MSH&apos;][&apos;MSH.3&apos;][&apos;MSH.3.3&apos;];

  var omlSendingFacNSID = msg[&apos;MSH&apos;][&apos;MSH.4&apos;][&apos;MSH.4.1&apos;];
  var omlSendingFacUID = msg[&apos;MSH&apos;][&apos;MSH.4&apos;][&apos;MSH.4.2&apos;];
  var omlSendingFacUIDType = msg[&apos;MSH&apos;][&apos;MSH.4&apos;][&apos;MSH.4.3&apos;];

  var omlRecvAppNSID = msg[&apos;MSH&apos;][&apos;MSH.5&apos;][&apos;MSH.5.1&apos;];
  var omlRecvAppUID = msg[&apos;MSH&apos;][&apos;MSH.5&apos;][&apos;MSH.5.2&apos;];
  var omlRecvAppUIDType = msg[&apos;MSH&apos;][&apos;MSH.5&apos;][&apos;MSH.5.3&apos;];

  var omlRecvFacNSID = msg[&apos;MSH&apos;][&apos;MSH.6&apos;][&apos;MSH.6.1&apos;];
  var omlRecvFacUID = msg[&apos;MSH&apos;][&apos;MSH.6&apos;][&apos;MSH.6.2&apos;];
  var omlRecvFacUIDType = msg[&apos;MSH&apos;][&apos;MSH.6&apos;][&apos;MSH.6.3&apos;];

  var omlCtrlID = msg[&apos;MSH&apos;][&apos;MSH.10&apos;][&apos;MSH.10.1&apos;];

  // Alter MSH contents with ACK-specific contents: Reverse sender and receiver.
  msg[&apos;MSH&apos;][&apos;MSH.3&apos;][&apos;MSH.3.1&apos;] = omlRecvAppNSID;
  msg[&apos;MSH&apos;][&apos;MSH.3&apos;][&apos;MSH.3.2&apos;] = omlRecvAppUID;
  msg[&apos;MSH&apos;][&apos;MSH.3&apos;][&apos;MSH.3.3&apos;] = omlRecvAppUIDType;

  msg[&apos;MSH&apos;][&apos;MSH.4&apos;][&apos;MSH.4.1&apos;] = omlRecvFacNSID;
  msg[&apos;MSH&apos;][&apos;MSH.4&apos;][&apos;MSH.4.2&apos;] = omlRecvFacUID;
  msg[&apos;MSH&apos;][&apos;MSH.4&apos;][&apos;MSH.4.3&apos;] = omlRecvFacUIDType;

  msg[&apos;MSH&apos;][&apos;MSH.5&apos;][&apos;MSH.5.1&apos;] = omlSendingAppNSID;
  msg[&apos;MSH&apos;][&apos;MSH.5&apos;][&apos;MSH.5.2&apos;] = omlSendingAppUID;
  msg[&apos;MSH&apos;][&apos;MSH.5&apos;][&apos;MSH.5.3&apos;] = omlSendingAppUIDType;

  msg[&apos;MSH&apos;][&apos;MSH.6&apos;][&apos;MSH.6.1&apos;] = omlSendingFacNSID;
  msg[&apos;MSH&apos;][&apos;MSH.6&apos;][&apos;MSH.6.2&apos;] = omlSendingFacUID;
  msg[&apos;MSH&apos;][&apos;MSH.6&apos;][&apos;MSH.6.3&apos;] = omlSendingFacUIDType;

  var curDateStamp = DateUtil.getCurrentDate(&quot;yyyyMMddHHmmss&quot;); //e.g, 20110623093000
  msg[&apos;MSH&apos;][&apos;MSH.7&apos;] = curDateStamp;
  msg[&apos;MSH&apos;][&apos;MSH.9&apos;] = &quot;ACK^O33^ACK&quot;;
  msg[&apos;MSH&apos;][&apos;MSH.10&apos;] = &quot;2.16.840.1.114222.4.3.2.5.2.7001.&quot; + curDateStamp + &quot;.0000&quot;;

  // add MSA segment
  createSegmentAfter(&apos;MSA&apos;, msg[&apos;MSH&apos;]);
  msg[&apos;MSA&apos;][&apos;MSA.1&apos;] = &quot;AA&quot;;
  msg[&apos;MSA&apos;][&apos;MSA.2&apos;] = omlCtrlID;

}
catch(e)
{
  logger.error(&quot;Error in Send ACK msg Transformer: &quot; + e.message);
  channelMap.put(&apos;componentErrors&apos;,  $(&apos;componentErrors&apos;) + &quot;Send ACK msg Transformer:\n&quot; + e.message + &quot; |\n&quot;);
}</string>
              </entry>
            </data>
          </step>
        </steps>
        <inboundTemplate encoding="base64"></inboundTemplate>
        <outboundTemplate encoding="base64"></outboundTemplate>
        <inboundProtocol>HL7V2</inboundProtocol>
        <outboundProtocol>HL7V2</outboundProtocol>
        <inboundProperties>
          <property name="convertLFtoCR">true</property>
          <property name="handleRepetitions">false</property>
          <property name="handleSubcomponents">false</property>
          <property name="stripNamespaces">true</property>
          <property name="useStrictParser">false</property>
          <property name="useStrictValidation">false</property>
        </inboundProperties>
        <outboundProperties>
          <property name="convertLFtoCR">true</property>
          <property name="handleRepetitions">false</property>
          <property name="handleSubcomponents">false</property>
          <property name="stripNamespaces">true</property>
          <property name="useStrictParser">false</property>
          <property name="useStrictValidation">false</property>
        </outboundProperties>
      </transformer>
      <filter>
        <rules>
          <rule>
            <sequenceNumber>0</sequenceNumber>
            <name>filter for 2.6 OML_O33 and MIRTH_WS xport</name>
            <data class="map">
              <entry>
                <string>Script</string>
                <string>var retval = false;

// Unfortunately, this version of Mirth does not seem to support variables inside web service endpoint URLs.
// This outermost conditional filters for phix2.phiresearchlab.org:8081 (PHIX 2) specifically (shouldn&apos;t be necessary).
if ($(&apos;sendingFacilityWebSvcHost&apos;) == &apos;phix2.phiresearchlab.org:8081&apos;)
{

  if ($(&apos;sendingFacilityXportType&apos;) == &apos;MIRTH_WS&apos; &amp;&amp;
      $(&apos;msgType&apos;) == &apos;OML&apos; &amp;&amp;
      $(&apos;msgTriggerEvent&apos;) == &apos;O33&apos; &amp;&amp;
      $(&apos;msgHL7VersionID&apos;) == &apos;2.6&apos; &amp;&amp;
      $(&apos;hubHost&apos;) == $(&apos;receivingFacilityHubHost&apos;))
  {
    if ($(&apos;componentErrors&apos;).length() &gt; 0)
    {
      logger.info(&quot;Bypassing Send ACK because of prior errors: &quot; + $(&apos;componentErrors&apos;));
    }
    else
    {
      logger.info(&quot;Received an 2.6 OML O33 msg. Sending ACK back to original Sending Facility over Mirth WS.&quot;);
      retval = true;
    }
  }

}

if (retval)
{
  channelMap.put(&apos;ackSentStatus&apos;, &apos;SENT VIA WS&apos;);
}
else
{
  channelMap.put(&apos;ackSentStatus&apos;, &apos;BYPASSED&apos;);
}

return retval;</string>
              </entry>
            </data>
            <type>JavaScript</type>
            <script>var retval = false;

// Unfortunately, this version of Mirth does not seem to support variables inside web service endpoint URLs.
// This outermost conditional filters for phix2.phiresearchlab.org:8081 (PHIX 2) specifically (shouldn&apos;t be necessary).
if ($(&apos;sendingFacilityWebSvcHost&apos;) == &apos;phix2.phiresearchlab.org:8081&apos;)
{

  if ($(&apos;sendingFacilityXportType&apos;) == &apos;MIRTH_WS&apos; &amp;&amp;
      $(&apos;msgType&apos;) == &apos;OML&apos; &amp;&amp;
      $(&apos;msgTriggerEvent&apos;) == &apos;O33&apos; &amp;&amp;
      $(&apos;msgHL7VersionID&apos;) == &apos;2.6&apos; &amp;&amp;
      $(&apos;hubHost&apos;) == $(&apos;receivingFacilityHubHost&apos;))
  {
    if ($(&apos;componentErrors&apos;).length() &gt; 0)
    {
      logger.info(&quot;Bypassing Send ACK because of prior errors: &quot; + $(&apos;componentErrors&apos;));
    }
    else
    {
      logger.info(&quot;Received an 2.6 OML O33 msg. Sending ACK back to original Sending Facility over Mirth WS.&quot;);
      retval = true;
    }
  }

}

if (retval)
{
  channelMap.put(&apos;ackSentStatus&apos;, &apos;SENT VIA WS&apos;);
}
else
{
  channelMap.put(&apos;ackSentStatus&apos;, &apos;BYPASSED&apos;);
}

return retval;</script>
            <operator>NONE</operator>
          </rule>
        </rules>
      </filter>
      <transportName>Web Service Sender</transportName>
      <mode>DESTINATION</mode>
      <enabled>false</enabled>
      <version>2.2.0.5828</version>
    </connector>
    <connector>
      <name>Send ACK msg (NHIN DIRECT REST)</name>
      <properties>
        <property name="DataType">JavaScript Writer</property>
        <property name="host">sink</property>
        <property name="script">var sndr = new Packages.gov.cdc.phlissa.hub.direct.HubDirectSender();
var subject = &quot;HL7 Message - &quot; + messageObject.getSource().toString();
// Note that &quot;sendingFacility&quot; is the sender of the original OML msg, which should receive this ACK
var toAddress = $(&apos;sendingFacilityDirectEmailAddress&apos;);

var lname = sndr.getLogName();

logger.info(lname + &quot; - Host: &quot; + sndr.getHost() );
logger.info(lname + &quot; - Port: &quot; + sndr.getPort() );
logger.info(lname + &quot; - From: &quot; + sndr.getFromAddress() );
logger.info(lname + &quot; - To: &quot; + toAddress);
logger.info(lname + &quot; - Subject: &quot; + subject);
logger.info(lname + &quot; - Trust store: &quot; + sndr.getTrustStorePath() );
logger.info(lname + &quot; - Trust store password: &quot; + sndr.getTrustStorePassword() );

sndr.sendDirectMessage(toAddress, subject, messageObject.getEncodedData().toString(), true);&#xd;
var hasError = sndr.hasError();

if (hasError) 
{
  logger.info(lname + &quot; - Error Message: &quot; + sndr.getErrorMessage() );
} 
else 
{
  logger.info(lname + &quot; - Message Location: &quot; + sndr.getLocation() );
  logger.info(lname + &quot; - Direct Response: &quot; + sndr.getResponse() );
}</property>
      </properties>
      <transformer>
        <steps>
          <step>
            <sequenceNumber>0</sequenceNumber>
            <name>transform OML msg into ACK msg</name>
            <script>try
{
  // build new ACK msg out of incoming OML msg

  // delete non-MSH OML segments
  for each (seg in msg.children() )
  {
    //logger.info(&quot;DEBUG: SEG &quot; + seg.name().toString() );
    if (seg.name().toString() != &apos;MSH&apos;)
    {
      //logger.info(&quot;DEBUG: Deleting SEG &quot; + seg.name().toString() );
      delete msg[seg.name().toString()];
    }
  }

  // Obtain orig sender &amp; receiver values from OML header. 
  var omlSendingAppNSID = msg[&apos;MSH&apos;][&apos;MSH.3&apos;][&apos;MSH.3.1&apos;];
  var omlSendingAppUID = msg[&apos;MSH&apos;][&apos;MSH.3&apos;][&apos;MSH.3.2&apos;];
  var omlSendingAppUIDType = msg[&apos;MSH&apos;][&apos;MSH.3&apos;][&apos;MSH.3.3&apos;];

  var omlSendingFacNSID = msg[&apos;MSH&apos;][&apos;MSH.4&apos;][&apos;MSH.4.1&apos;];
  var omlSendingFacUID = msg[&apos;MSH&apos;][&apos;MSH.4&apos;][&apos;MSH.4.2&apos;];
  var omlSendingFacUIDType = msg[&apos;MSH&apos;][&apos;MSH.4&apos;][&apos;MSH.4.3&apos;];

  var omlRecvAppNSID = msg[&apos;MSH&apos;][&apos;MSH.5&apos;][&apos;MSH.5.1&apos;];
  var omlRecvAppUID = msg[&apos;MSH&apos;][&apos;MSH.5&apos;][&apos;MSH.5.2&apos;];
  var omlRecvAppUIDType = msg[&apos;MSH&apos;][&apos;MSH.5&apos;][&apos;MSH.5.3&apos;];

  var omlRecvFacNSID = msg[&apos;MSH&apos;][&apos;MSH.6&apos;][&apos;MSH.6.1&apos;];
  var omlRecvFacUID = msg[&apos;MSH&apos;][&apos;MSH.6&apos;][&apos;MSH.6.2&apos;];
  var omlRecvFacUIDType = msg[&apos;MSH&apos;][&apos;MSH.6&apos;][&apos;MSH.6.3&apos;];

  var omlCtrlID = msg[&apos;MSH&apos;][&apos;MSH.10&apos;][&apos;MSH.10.1&apos;];

  // Alter MSH contents with ACK-specific contents: Reverse sender and receiver.
  msg[&apos;MSH&apos;][&apos;MSH.3&apos;][&apos;MSH.3.1&apos;] = omlRecvAppNSID;
  msg[&apos;MSH&apos;][&apos;MSH.3&apos;][&apos;MSH.3.2&apos;] = omlRecvAppUID;
  msg[&apos;MSH&apos;][&apos;MSH.3&apos;][&apos;MSH.3.3&apos;] = omlRecvAppUIDType;

  msg[&apos;MSH&apos;][&apos;MSH.4&apos;][&apos;MSH.4.1&apos;] = omlRecvFacNSID;
  msg[&apos;MSH&apos;][&apos;MSH.4&apos;][&apos;MSH.4.2&apos;] = omlRecvFacUID;
  msg[&apos;MSH&apos;][&apos;MSH.4&apos;][&apos;MSH.4.3&apos;] = omlRecvFacUIDType;

  msg[&apos;MSH&apos;][&apos;MSH.5&apos;][&apos;MSH.5.1&apos;] = omlSendingAppNSID;
  msg[&apos;MSH&apos;][&apos;MSH.5&apos;][&apos;MSH.5.2&apos;] = omlSendingAppUID;
  msg[&apos;MSH&apos;][&apos;MSH.5&apos;][&apos;MSH.5.3&apos;] = omlSendingAppUIDType;

  msg[&apos;MSH&apos;][&apos;MSH.6&apos;][&apos;MSH.6.1&apos;] = omlSendingFacNSID;
  msg[&apos;MSH&apos;][&apos;MSH.6&apos;][&apos;MSH.6.2&apos;] = omlSendingFacUID;
  msg[&apos;MSH&apos;][&apos;MSH.6&apos;][&apos;MSH.6.3&apos;] = omlSendingFacUIDType;

  var curDateStamp = DateUtil.getCurrentDate(&quot;yyyyMMddHHmmss&quot;); //e.g, 20110623093000
  msg[&apos;MSH&apos;][&apos;MSH.7&apos;] = curDateStamp;
  msg[&apos;MSH&apos;][&apos;MSH.9&apos;] = &quot;ACK^O33^ACK&quot;;
  msg[&apos;MSH&apos;][&apos;MSH.10&apos;] = &quot;2.16.840.1.114222.4.3.2.5.2.7001.&quot; + curDateStamp + &quot;.0000&quot;;

  // add MSA segment
  createSegmentAfter(&apos;MSA&apos;, msg[&apos;MSH&apos;]);
  msg[&apos;MSA&apos;][&apos;MSA.1&apos;] = &quot;AA&quot;;
  msg[&apos;MSA&apos;][&apos;MSA.2&apos;] = omlCtrlID;

}
catch(e)
{
  logger.error(&quot;Error in Send ACK msg Transformer: &quot; + e.message);
  channelMap.put(&apos;componentErrors&apos;,  $(&apos;componentErrors&apos;) + &quot;Send ACK msg Transformer:\n&quot; + e.message + &quot; |\n&quot;);
}</script>
            <type>JavaScript</type>
            <data class="map">
              <entry>
                <string>Script</string>
                <string>try
{
  // build new ACK msg out of incoming OML msg

  // delete non-MSH OML segments
  for each (seg in msg.children() )
  {
    //logger.info(&quot;DEBUG: SEG &quot; + seg.name().toString() );
    if (seg.name().toString() != &apos;MSH&apos;)
    {
      //logger.info(&quot;DEBUG: Deleting SEG &quot; + seg.name().toString() );
      delete msg[seg.name().toString()];
    }
  }

  // Obtain orig sender &amp; receiver values from OML header. 
  var omlSendingAppNSID = msg[&apos;MSH&apos;][&apos;MSH.3&apos;][&apos;MSH.3.1&apos;];
  var omlSendingAppUID = msg[&apos;MSH&apos;][&apos;MSH.3&apos;][&apos;MSH.3.2&apos;];
  var omlSendingAppUIDType = msg[&apos;MSH&apos;][&apos;MSH.3&apos;][&apos;MSH.3.3&apos;];

  var omlSendingFacNSID = msg[&apos;MSH&apos;][&apos;MSH.4&apos;][&apos;MSH.4.1&apos;];
  var omlSendingFacUID = msg[&apos;MSH&apos;][&apos;MSH.4&apos;][&apos;MSH.4.2&apos;];
  var omlSendingFacUIDType = msg[&apos;MSH&apos;][&apos;MSH.4&apos;][&apos;MSH.4.3&apos;];

  var omlRecvAppNSID = msg[&apos;MSH&apos;][&apos;MSH.5&apos;][&apos;MSH.5.1&apos;];
  var omlRecvAppUID = msg[&apos;MSH&apos;][&apos;MSH.5&apos;][&apos;MSH.5.2&apos;];
  var omlRecvAppUIDType = msg[&apos;MSH&apos;][&apos;MSH.5&apos;][&apos;MSH.5.3&apos;];

  var omlRecvFacNSID = msg[&apos;MSH&apos;][&apos;MSH.6&apos;][&apos;MSH.6.1&apos;];
  var omlRecvFacUID = msg[&apos;MSH&apos;][&apos;MSH.6&apos;][&apos;MSH.6.2&apos;];
  var omlRecvFacUIDType = msg[&apos;MSH&apos;][&apos;MSH.6&apos;][&apos;MSH.6.3&apos;];

  var omlCtrlID = msg[&apos;MSH&apos;][&apos;MSH.10&apos;][&apos;MSH.10.1&apos;];

  // Alter MSH contents with ACK-specific contents: Reverse sender and receiver.
  msg[&apos;MSH&apos;][&apos;MSH.3&apos;][&apos;MSH.3.1&apos;] = omlRecvAppNSID;
  msg[&apos;MSH&apos;][&apos;MSH.3&apos;][&apos;MSH.3.2&apos;] = omlRecvAppUID;
  msg[&apos;MSH&apos;][&apos;MSH.3&apos;][&apos;MSH.3.3&apos;] = omlRecvAppUIDType;

  msg[&apos;MSH&apos;][&apos;MSH.4&apos;][&apos;MSH.4.1&apos;] = omlRecvFacNSID;
  msg[&apos;MSH&apos;][&apos;MSH.4&apos;][&apos;MSH.4.2&apos;] = omlRecvFacUID;
  msg[&apos;MSH&apos;][&apos;MSH.4&apos;][&apos;MSH.4.3&apos;] = omlRecvFacUIDType;

  msg[&apos;MSH&apos;][&apos;MSH.5&apos;][&apos;MSH.5.1&apos;] = omlSendingAppNSID;
  msg[&apos;MSH&apos;][&apos;MSH.5&apos;][&apos;MSH.5.2&apos;] = omlSendingAppUID;
  msg[&apos;MSH&apos;][&apos;MSH.5&apos;][&apos;MSH.5.3&apos;] = omlSendingAppUIDType;

  msg[&apos;MSH&apos;][&apos;MSH.6&apos;][&apos;MSH.6.1&apos;] = omlSendingFacNSID;
  msg[&apos;MSH&apos;][&apos;MSH.6&apos;][&apos;MSH.6.2&apos;] = omlSendingFacUID;
  msg[&apos;MSH&apos;][&apos;MSH.6&apos;][&apos;MSH.6.3&apos;] = omlSendingFacUIDType;

  var curDateStamp = DateUtil.getCurrentDate(&quot;yyyyMMddHHmmss&quot;); //e.g, 20110623093000
  msg[&apos;MSH&apos;][&apos;MSH.7&apos;] = curDateStamp;
  msg[&apos;MSH&apos;][&apos;MSH.9&apos;] = &quot;ACK^O33^ACK&quot;;
  msg[&apos;MSH&apos;][&apos;MSH.10&apos;] = &quot;2.16.840.1.114222.4.3.2.5.2.7001.&quot; + curDateStamp + &quot;.0000&quot;;

  // add MSA segment
  createSegmentAfter(&apos;MSA&apos;, msg[&apos;MSH&apos;]);
  msg[&apos;MSA&apos;][&apos;MSA.1&apos;] = &quot;AA&quot;;
  msg[&apos;MSA&apos;][&apos;MSA.2&apos;] = omlCtrlID;

}
catch(e)
{
  logger.error(&quot;Error in Send ACK msg Transformer: &quot; + e.message);
  channelMap.put(&apos;componentErrors&apos;,  $(&apos;componentErrors&apos;) + &quot;Send ACK msg Transformer:\n&quot; + e.message + &quot; |\n&quot;);
}</string>
              </entry>
            </data>
          </step>
        </steps>
        <inboundTemplate encoding="base64"></inboundTemplate>
        <outboundTemplate encoding="base64"></outboundTemplate>
        <inboundProtocol>HL7V2</inboundProtocol>
        <outboundProtocol>HL7V2</outboundProtocol>
        <inboundProperties>
          <property name="convertLFtoCR">true</property>
          <property name="handleRepetitions">false</property>
          <property name="handleSubcomponents">false</property>
          <property name="stripNamespaces">true</property>
          <property name="useStrictParser">false</property>
          <property name="useStrictValidation">false</property>
        </inboundProperties>
        <outboundProperties>
          <property name="convertLFtoCR">true</property>
          <property name="handleRepetitions">false</property>
          <property name="handleSubcomponents">false</property>
          <property name="stripNamespaces">true</property>
          <property name="useStrictParser">false</property>
          <property name="useStrictValidation">false</property>
        </outboundProperties>
      </transformer>
      <filter>
        <rules>
          <rule>
            <sequenceNumber>0</sequenceNumber>
            <name>filter for 2.6 OML_O33 and DIRECT xport</name>
            <data class="map">
              <entry>
                <string>Script</string>
                <string>var retval = false;

if ($(&apos;sendingFacilityXportType&apos;) == &apos;DIRECT&apos; &amp;&amp;
    $(&apos;msgType&apos;) == &apos;OML&apos; &amp;&amp;
    $(&apos;msgTriggerEvent&apos;) == &apos;O33&apos; &amp;&amp;
    $(&apos;msgHL7VersionID&apos;) == &apos;2.6&apos; &amp;&amp;
    $(&apos;hubHost&apos;) == $(&apos;receivingFacilityHubHost&apos;))
{

  if ($(&apos;componentErrors&apos;).length() &gt; 0)
  {
    logger.info(&quot;Bypassing Send ACK via DIRECT because of prior errors: &quot; + $(&apos;componentErrors&apos;));
  }
  else
  {
    logger.info(&quot;Received an 2.6 OML O33 msg. Sending ACK back to original Sending Facility over DIRECT.&quot;);
    retval = true;
  }
}

if (retval)
{
  channelMap.put(&apos;ackSentStatus&apos;, &apos;SENT VIA DIRECT&apos;);
}
else
{
  channelMap.put(&apos;ackSentStatus&apos;, &apos;BYPASSED&apos;);
}

return retval;</string>
              </entry>
            </data>
            <type>JavaScript</type>
            <script>var retval = false;

if ($(&apos;sendingFacilityXportType&apos;) == &apos;DIRECT&apos; &amp;&amp;
    $(&apos;msgType&apos;) == &apos;OML&apos; &amp;&amp;
    $(&apos;msgTriggerEvent&apos;) == &apos;O33&apos; &amp;&amp;
    $(&apos;msgHL7VersionID&apos;) == &apos;2.6&apos; &amp;&amp;
    $(&apos;hubHost&apos;) == $(&apos;receivingFacilityHubHost&apos;))
{

  if ($(&apos;componentErrors&apos;).length() &gt; 0)
  {
    logger.info(&quot;Bypassing Send ACK via DIRECT because of prior errors: &quot; + $(&apos;componentErrors&apos;));
  }
  else
  {
    logger.info(&quot;Received an 2.6 OML O33 msg. Sending ACK back to original Sending Facility over DIRECT.&quot;);
    retval = true;
  }
}

if (retval)
{
  channelMap.put(&apos;ackSentStatus&apos;, &apos;SENT VIA DIRECT&apos;);
}
else
{
  channelMap.put(&apos;ackSentStatus&apos;, &apos;BYPASSED&apos;);
}

return retval;</script>
            <operator>NONE</operator>
          </rule>
        </rules>
      </filter>
      <transportName>JavaScript Writer</transportName>
      <mode>DESTINATION</mode>
      <enabled>false</enabled>
      <version>2.2.0.5828</version>
    </connector>
    <connector>
      <name>Store transformed message to file</name>
      <properties>
        <property name="DataType">File Writer</property>
        <property name="FTPAnonymous">1</property>
        <property name="binary">0</property>
        <property name="charsetEncoding">DEFAULT_ENCODING</property>
        <property name="directory"></property>
        <property name="errorOnExists">0</property>
        <property name="host">C:/phixdata/HL7_TRANSFORMED</property>
        <property name="outputAppend">1</property>
        <property name="outputPattern">${timestamp}_XFORMED.txt</property>
        <property name="passive">1</property>
        <property name="password">anonymous</property>
        <property name="scheme">file</property>
        <property name="secure">1</property>
        <property name="template">${message.encodedData}</property>
        <property name="temporary">0</property>
        <property name="timeout">10000</property>
        <property name="username">anonymous</property>
        <property name="validateConnections">1</property>
      </properties>
      <transformer>
        <steps>
          <step>
            <sequenceNumber>0</sequenceNumber>
            <name>Apply Vocab Translation</name>
            <script>try
{
  // -- vocab translation --
  if ( $(&apos;stdObx31&apos;) != &apos;&apos; )
  {
    logger.info(&quot;Applying OBX.3 vocab translation to msg...&quot;);

    msg[&apos;OBX&apos;][&apos;OBX.3&apos;][&apos;OBX.3.1&apos;] = $(&apos;stdObx31&apos;);
    msg[&apos;OBX&apos;][&apos;OBX.3&apos;][&apos;OBX.3.2&apos;] = $(&apos;stdObx32&apos;);
    msg[&apos;OBX&apos;][&apos;OBX.3&apos;][&apos;OBX.3.3&apos;] = $(&apos;stdObx33&apos;);
  }

  if ( $(&apos;stdRxa51&apos;) != &apos;&apos; )
  {
    logger.info(&quot;Applying RXA.5 vocab translation to msg...&quot;);

    msg[&apos;RXA&apos;][&apos;RXA.5&apos;][&apos;RXA.5.1&apos;] = $(&apos;stdRxa51&apos;);
    msg[&apos;RXA&apos;][&apos;RXA.5&apos;][&apos;RXA.5.2&apos;] = $(&apos;stdRxa52&apos;);
    msg[&apos;RXA&apos;][&apos;RXA.5&apos;][&apos;RXA.5.3&apos;] = $(&apos;stdRxa53&apos;);
  }
}
catch(e)
{
  logger.error(&quot;Error in Store transformed message to file Transformer: Apply Vocal Translation: &quot; + e.message);
  channelMap.put(&apos;componentErrors&apos;,  $(&apos;componentErrors&apos;) + &quot;Store transformed message to file Transformer: Apply Vocal Translation: \n&quot; + e.message + &quot; |\n&quot;);
}</script>
            <type>JavaScript</type>
            <data class="map">
              <entry>
                <string>Script</string>
                <string>try
{
  // -- vocab translation --
  if ( $(&apos;stdObx31&apos;) != &apos;&apos; )
  {
    logger.info(&quot;Applying OBX.3 vocab translation to msg...&quot;);

    msg[&apos;OBX&apos;][&apos;OBX.3&apos;][&apos;OBX.3.1&apos;] = $(&apos;stdObx31&apos;);
    msg[&apos;OBX&apos;][&apos;OBX.3&apos;][&apos;OBX.3.2&apos;] = $(&apos;stdObx32&apos;);
    msg[&apos;OBX&apos;][&apos;OBX.3&apos;][&apos;OBX.3.3&apos;] = $(&apos;stdObx33&apos;);
  }

  if ( $(&apos;stdRxa51&apos;) != &apos;&apos; )
  {
    logger.info(&quot;Applying RXA.5 vocab translation to msg...&quot;);

    msg[&apos;RXA&apos;][&apos;RXA.5&apos;][&apos;RXA.5.1&apos;] = $(&apos;stdRxa51&apos;);
    msg[&apos;RXA&apos;][&apos;RXA.5&apos;][&apos;RXA.5.2&apos;] = $(&apos;stdRxa52&apos;);
    msg[&apos;RXA&apos;][&apos;RXA.5&apos;][&apos;RXA.5.3&apos;] = $(&apos;stdRxa53&apos;);
  }
}
catch(e)
{
  logger.error(&quot;Error in Store transformed message to file Transformer: Apply Vocal Translation: &quot; + e.message);
  channelMap.put(&apos;componentErrors&apos;,  $(&apos;componentErrors&apos;) + &quot;Store transformed message to file Transformer: Apply Vocal Translation: \n&quot; + e.message + &quot; |\n&quot;);
}</string>
              </entry>
            </data>
          </step>
          <step>
            <sequenceNumber>1</sequenceNumber>
            <name>Add SFT Segment</name>
            <script>try
{
  if ($(&apos;addSFTSegment&apos;) == &apos;true&apos;)
  {
    logger.info(&quot;Adding SFT Segment&quot;);

    // determine how many SFT segements already exist
    var i = 0;
  
    while(msg[&apos;SFT&apos;][i] != null) 
    {  
      ++i;
    }

    // create SFT segment, per requirements in &quot;Message Processing Flow&quot; spreadsheet
    var newSFT = createSegment(&apos;SFT&apos;);

    // workaround to put the new segment after the existing SFT, if another exists, otherwise after MSH
    if (i == 0)
    {
      msg[&apos;MSH&apos;] += newSFT;
    }
    else
    {
      msg[&apos;SFT&apos;] += newSFT;
    }

    msg[&apos;SFT&apos;][i][&apos;SFT.1&apos;][&apos;SFT.1.1&apos;] = &apos;PHIX&apos;;
    msg[&apos;SFT&apos;][i][&apos;SFT.1&apos;][&apos;SFT.1.2&apos;] = &apos;L&apos;;
    msg[&apos;SFT&apos;][i][&apos;SFT.1&apos;][&apos;SFT.1.6&apos;][&apos;SFT.1.6.1&apos;] = &apos;&apos;;
    msg[&apos;SFT&apos;][i][&apos;SFT.1&apos;][&apos;SFT.1.6&apos;][&apos;SFT.1.6.2&apos;] = &apos;2.16.840.1.114222.4.3.2.5.2.4000&apos;;
    msg[&apos;SFT&apos;][i][&apos;SFT.1&apos;][&apos;SFT.1.6&apos;][&apos;SFT.1.6.3&apos;] = &apos;ISO&apos;;
    msg[&apos;SFT&apos;][i][&apos;SFT.1&apos;][&apos;SFT.1.7&apos;] = &apos;XX&apos;;
    msg[&apos;SFT&apos;][i][&apos;SFT.1&apos;][&apos;SFT.1.10&apos;] = &apos;PHIX&apos;;

    msg[&apos;SFT&apos;][i][&apos;SFT.2&apos;] = &apos;1.3&apos;;
    msg[&apos;SFT&apos;][i][&apos;SFT.3&apos;] = &apos;PHIX&apos;;
    msg[&apos;SFT&apos;][i][&apos;SFT.4&apos;] = &apos;1.3&apos;;

    msg[&apos;SFT&apos;][i][&apos;SFT.6&apos;] = &apos;&apos;;
  }
}
catch(e)
{
  logger.error(&quot;Error in Store transformed message to file Transformer: Add SFT Segment: &quot; + e.message);
  channelMap.put(&apos;componentErrors&apos;,  $(&apos;componentErrors&apos;) + &quot;Store transformed message to file Transformer: Add SFT Segment: \n&quot; + e.message + &quot; |\n&quot;);
}</script>
            <type>JavaScript</type>
            <data class="map">
              <entry>
                <string>Script</string>
                <string>try
{
  if ($(&apos;addSFTSegment&apos;) == &apos;true&apos;)
  {
    logger.info(&quot;Adding SFT Segment&quot;);

    // determine how many SFT segements already exist
    var i = 0;
  
    while(msg[&apos;SFT&apos;][i] != null) 
    {  
      ++i;
    }

    // create SFT segment, per requirements in &quot;Message Processing Flow&quot; spreadsheet
    var newSFT = createSegment(&apos;SFT&apos;);

    // workaround to put the new segment after the existing SFT, if another exists, otherwise after MSH
    if (i == 0)
    {
      msg[&apos;MSH&apos;] += newSFT;
    }
    else
    {
      msg[&apos;SFT&apos;] += newSFT;
    }

    msg[&apos;SFT&apos;][i][&apos;SFT.1&apos;][&apos;SFT.1.1&apos;] = &apos;PHIX&apos;;
    msg[&apos;SFT&apos;][i][&apos;SFT.1&apos;][&apos;SFT.1.2&apos;] = &apos;L&apos;;
    msg[&apos;SFT&apos;][i][&apos;SFT.1&apos;][&apos;SFT.1.6&apos;][&apos;SFT.1.6.1&apos;] = &apos;&apos;;
    msg[&apos;SFT&apos;][i][&apos;SFT.1&apos;][&apos;SFT.1.6&apos;][&apos;SFT.1.6.2&apos;] = &apos;2.16.840.1.114222.4.3.2.5.2.4000&apos;;
    msg[&apos;SFT&apos;][i][&apos;SFT.1&apos;][&apos;SFT.1.6&apos;][&apos;SFT.1.6.3&apos;] = &apos;ISO&apos;;
    msg[&apos;SFT&apos;][i][&apos;SFT.1&apos;][&apos;SFT.1.7&apos;] = &apos;XX&apos;;
    msg[&apos;SFT&apos;][i][&apos;SFT.1&apos;][&apos;SFT.1.10&apos;] = &apos;PHIX&apos;;

    msg[&apos;SFT&apos;][i][&apos;SFT.2&apos;] = &apos;1.3&apos;;
    msg[&apos;SFT&apos;][i][&apos;SFT.3&apos;] = &apos;PHIX&apos;;
    msg[&apos;SFT&apos;][i][&apos;SFT.4&apos;] = &apos;1.3&apos;;

    msg[&apos;SFT&apos;][i][&apos;SFT.6&apos;] = &apos;&apos;;
  }
}
catch(e)
{
  logger.error(&quot;Error in Store transformed message to file Transformer: Add SFT Segment: &quot; + e.message);
  channelMap.put(&apos;componentErrors&apos;,  $(&apos;componentErrors&apos;) + &quot;Store transformed message to file Transformer: Add SFT Segment: \n&quot; + e.message + &quot; |\n&quot;);
}</string>
              </entry>
            </data>
          </step>
          <step>
            <sequenceNumber>2</sequenceNumber>
            <name>Add SPM Segment</name>
            <script>try
{
  if ($(&apos;addSPMSegment&apos;) == &apos;true&apos;)
  {
    logger.info(&quot;Adding SPM Segment&quot;);

    //var newSPM = createSegment(&apos;SPM&apos;);
    //msg[&apos;OBR&apos;] += newSPM;

    // Create SPM segment, per requirements in &quot;Message Processing Flow&quot; spreadsheet
    // (Not specifying a location should place it last, which is where it belongs)
  
    msg[&apos;SPM&apos;][&apos;SPM.1&apos;] = &apos;1&apos;;
    //msg[&apos;SPM&apos;][&apos;SPM.2&apos;][&apos;SPM.2.2&apos;][&apos;SPM.2.2.1&apos;] = msg[&apos;OBR&apos;][&apos;OBR.3&apos;][&apos;OBR.3.1&apos;];
    //msg[&apos;SPM&apos;][&apos;SPM.2&apos;][&apos;SPM.2.2&apos;][&apos;SPM.2.2.2&apos;] = msg[&apos;OBR&apos;][&apos;OBR.3&apos;][&apos;OBR.3.2&apos;];
    //msg[&apos;SPM&apos;][&apos;SPM.2&apos;][&apos;SPM.2.2&apos;][&apos;SPM.2.2.3&apos;] = msg[&apos;OBR&apos;][&apos;OBR.3&apos;][&apos;OBR.3.3&apos;];
    //msg[&apos;SPM&apos;][&apos;SPM.2&apos;][&apos;SPM.2.2&apos;][&apos;SPM.2.2.4&apos;] = msg[&apos;OBR&apos;][&apos;OBR.3&apos;][&apos;OBR.3.4&apos;];

    msg[&apos;SPM&apos;][&apos;SPM.2&apos;][&apos;SPM.2.2&apos;] = msg[&apos;OBR&apos;][&apos;OBR.3&apos;][&apos;OBR.3.1&apos;].toString() + &quot;&amp;&quot; +
                                     msg[&apos;OBR&apos;][&apos;OBR.3&apos;][&apos;OBR.3.2&apos;].toString() + &quot;&amp;&quot; +
                                     msg[&apos;OBR&apos;][&apos;OBR.3&apos;][&apos;OBR.3.3&apos;].toString() + &quot;&amp;&quot; +
                                     msg[&apos;OBR&apos;][&apos;OBR.3&apos;][&apos;OBR.3.4&apos;].toString();


    // Mirth apparently cannot support deeper than seg.x.y, so it&apos;s necessary to 
    // handle the subdivisions of the fields beyond this using split().
    var specSrcList = msg[&apos;OBR&apos;][&apos;OBR.15&apos;][&apos;OBR.15.1&apos;].toString().split(&quot;&amp;&quot;);
    if (specSrcList.length &gt;= 3)
    {
      msg[&apos;SPM&apos;][&apos;SPM.4&apos;][&apos;SPM.4.1&apos;] = specSrcList[0]; // OBR.15.1.1
      msg[&apos;SPM&apos;][&apos;SPM.4&apos;][&apos;SPM.4.2&apos;] = specSrcList[1]; // OBR.15.1.2
      msg[&apos;SPM&apos;][&apos;SPM.4&apos;][&apos;SPM.4.3&apos;] = specSrcList[2]; // OBR.15.1.3
    }

    var bodySiteList = msg[&apos;OBR&apos;][&apos;OBR.15&apos;][&apos;OBR.15.4&apos;].toString().split(&quot;&amp;&quot;);
    if (bodySiteList.length &gt;= 3)
    {
      msg[&apos;SPM&apos;][&apos;SPM.8&apos;][&apos;SPM.8.1&apos;] = bodySiteList[0]; // OBR.15.4.1
      msg[&apos;SPM&apos;][&apos;SPM.8&apos;][&apos;SPM.8.2&apos;] = bodySiteList[1]; // OBR.15.4.2
      msg[&apos;SPM&apos;][&apos;SPM.8&apos;][&apos;SPM.8.3&apos;] = bodySiteList[2]; // OBR.15.4.3
    }

    msg[&apos;SPM&apos;][&apos;SPM.17&apos;][&apos;SPM.17.1&apos;] = msg[&apos;OBR&apos;][&apos;OBR.7&apos;][&apos;OBR.7.1&apos;].toString();
    msg[&apos;SPM&apos;][&apos;SPM.18&apos;] = msg[&apos;OBR&apos;][&apos;OBR.14&apos;][&apos;OBR.14.1&apos;].toString();

    msg[&apos;SPM&apos;][&apos;SPM.26&apos;] = &apos;&apos;;
  

    // Remove OBX, re-add OBX.  This should re-order the msg correctly so that OBX is last.
    //var obx = msg[&apos;OBX&apos;];
    //delete msg[&apos;OBX&apos;];
    //msg[&apos;OBX&apos;] = obx;
  }
}
catch(e)
{
  logger.error(&quot;Error in Store transformed message to file Transformer: Add SPM Segment: &quot; + e.message);
  channelMap.put(&apos;componentErrors&apos;,  $(&apos;componentErrors&apos;) + &quot;Store transformed message to file Transformer: Add SPM Segment: \n&quot; + e.message + &quot; |\n&quot;);
}</script>
            <type>JavaScript</type>
            <data class="map">
              <entry>
                <string>Script</string>
                <string>try
{
  if ($(&apos;addSPMSegment&apos;) == &apos;true&apos;)
  {
    logger.info(&quot;Adding SPM Segment&quot;);

    //var newSPM = createSegment(&apos;SPM&apos;);
    //msg[&apos;OBR&apos;] += newSPM;

    // Create SPM segment, per requirements in &quot;Message Processing Flow&quot; spreadsheet
    // (Not specifying a location should place it last, which is where it belongs)
  
    msg[&apos;SPM&apos;][&apos;SPM.1&apos;] = &apos;1&apos;;
    //msg[&apos;SPM&apos;][&apos;SPM.2&apos;][&apos;SPM.2.2&apos;][&apos;SPM.2.2.1&apos;] = msg[&apos;OBR&apos;][&apos;OBR.3&apos;][&apos;OBR.3.1&apos;];
    //msg[&apos;SPM&apos;][&apos;SPM.2&apos;][&apos;SPM.2.2&apos;][&apos;SPM.2.2.2&apos;] = msg[&apos;OBR&apos;][&apos;OBR.3&apos;][&apos;OBR.3.2&apos;];
    //msg[&apos;SPM&apos;][&apos;SPM.2&apos;][&apos;SPM.2.2&apos;][&apos;SPM.2.2.3&apos;] = msg[&apos;OBR&apos;][&apos;OBR.3&apos;][&apos;OBR.3.3&apos;];
    //msg[&apos;SPM&apos;][&apos;SPM.2&apos;][&apos;SPM.2.2&apos;][&apos;SPM.2.2.4&apos;] = msg[&apos;OBR&apos;][&apos;OBR.3&apos;][&apos;OBR.3.4&apos;];

    msg[&apos;SPM&apos;][&apos;SPM.2&apos;][&apos;SPM.2.2&apos;] = msg[&apos;OBR&apos;][&apos;OBR.3&apos;][&apos;OBR.3.1&apos;].toString() + &quot;&amp;&quot; +
                                     msg[&apos;OBR&apos;][&apos;OBR.3&apos;][&apos;OBR.3.2&apos;].toString() + &quot;&amp;&quot; +
                                     msg[&apos;OBR&apos;][&apos;OBR.3&apos;][&apos;OBR.3.3&apos;].toString() + &quot;&amp;&quot; +
                                     msg[&apos;OBR&apos;][&apos;OBR.3&apos;][&apos;OBR.3.4&apos;].toString();


    // Mirth apparently cannot support deeper than seg.x.y, so it&apos;s necessary to 
    // handle the subdivisions of the fields beyond this using split().
    var specSrcList = msg[&apos;OBR&apos;][&apos;OBR.15&apos;][&apos;OBR.15.1&apos;].toString().split(&quot;&amp;&quot;);
    if (specSrcList.length &gt;= 3)
    {
      msg[&apos;SPM&apos;][&apos;SPM.4&apos;][&apos;SPM.4.1&apos;] = specSrcList[0]; // OBR.15.1.1
      msg[&apos;SPM&apos;][&apos;SPM.4&apos;][&apos;SPM.4.2&apos;] = specSrcList[1]; // OBR.15.1.2
      msg[&apos;SPM&apos;][&apos;SPM.4&apos;][&apos;SPM.4.3&apos;] = specSrcList[2]; // OBR.15.1.3
    }

    var bodySiteList = msg[&apos;OBR&apos;][&apos;OBR.15&apos;][&apos;OBR.15.4&apos;].toString().split(&quot;&amp;&quot;);
    if (bodySiteList.length &gt;= 3)
    {
      msg[&apos;SPM&apos;][&apos;SPM.8&apos;][&apos;SPM.8.1&apos;] = bodySiteList[0]; // OBR.15.4.1
      msg[&apos;SPM&apos;][&apos;SPM.8&apos;][&apos;SPM.8.2&apos;] = bodySiteList[1]; // OBR.15.4.2
      msg[&apos;SPM&apos;][&apos;SPM.8&apos;][&apos;SPM.8.3&apos;] = bodySiteList[2]; // OBR.15.4.3
    }

    msg[&apos;SPM&apos;][&apos;SPM.17&apos;][&apos;SPM.17.1&apos;] = msg[&apos;OBR&apos;][&apos;OBR.7&apos;][&apos;OBR.7.1&apos;].toString();
    msg[&apos;SPM&apos;][&apos;SPM.18&apos;] = msg[&apos;OBR&apos;][&apos;OBR.14&apos;][&apos;OBR.14.1&apos;].toString();

    msg[&apos;SPM&apos;][&apos;SPM.26&apos;] = &apos;&apos;;
  

    // Remove OBX, re-add OBX.  This should re-order the msg correctly so that OBX is last.
    //var obx = msg[&apos;OBX&apos;];
    //delete msg[&apos;OBX&apos;];
    //msg[&apos;OBX&apos;] = obx;
  }
}
catch(e)
{
  logger.error(&quot;Error in Store transformed message to file Transformer: Add SPM Segment: &quot; + e.message);
  channelMap.put(&apos;componentErrors&apos;,  $(&apos;componentErrors&apos;) + &quot;Store transformed message to file Transformer: Add SPM Segment: \n&quot; + e.message + &quot; |\n&quot;);
}</string>
              </entry>
            </data>
          </step>
          <step>
            <sequenceNumber>3</sequenceNumber>
            <name>ORU R01 2.3.1 to 2.5.1 Transformation</name>
            <script>try
{
  // 2.3.1 to 2.5.1 ORU R01-specific MSH transformations
  if ( ($(&apos;translateToVersion&apos;) == &apos;2.5.1&apos;) &amp;&amp;
       ($(&apos;msgType&apos;) == &apos;ORU&apos;) &amp;&amp;
       ($(&apos;msgTriggerEvent&apos;) == &apos;R01&apos;) &amp;&amp;
       ($(&apos;msgHL7VersionID&apos;) == &apos;2.3.1&apos;) )
  {
    logger.info(&quot;Transforming ORU R01 2.3.1 message to 2.5.1&quot;);

    // MSH additions
    msg[&apos;MSH&apos;][&apos;MSH.12&apos;] = &apos;2.5.1&apos;;&#xd;
    msg[&apos;MSH&apos;][&apos;MSH.9&apos;][&apos;MSH.9.3&apos;] = &apos;ORU_R01&apos;;&#xd;
    msg[&apos;MSH&apos;][&apos;MSH.21&apos;][&apos;MSH.21.1&apos;] = &apos;V251_IG_LB_LABRPTPH_R1_INFORM_2010FEB&apos;;
    msg[&apos;MSH&apos;][&apos;MSH.21&apos;][&apos;MSH.21.2&apos;] = &apos;&apos;;
    msg[&apos;MSH&apos;][&apos;MSH.21&apos;][&apos;MSH.21.3&apos;] = &apos;2.16.840.1.114222.4.3.2.5.2.5&apos;;
    msg[&apos;MSH&apos;][&apos;MSH.21&apos;][&apos;MSH.21.4&apos;] = &apos;ISO&apos;;

    // OBR deletions
    msg[&apos;OBR&apos;][&apos;OBR.14&apos;] = &apos;&apos;;
    msg[&apos;OBR&apos;][&apos;OBR.15&apos;] = &apos;&apos;;

    // OBX additions
    msg[&apos;OBX&apos;][&apos;OBX.23&apos;] = &quot;INFORMATION NOT AVAILABLE&quot;;
    msg[&apos;OBX&apos;][&apos;OBX.24&apos;][&apos;OBX.24.1&apos;] = &quot;INFORMATION NOT AVAILABLE&quot;;
    msg[&apos;OBX&apos;][&apos;OBX.24&apos;][&apos;OBX.24.2&apos;] = &apos;&apos;;
    msg[&apos;OBX&apos;][&apos;OBX.24&apos;][&apos;OBX.24.3&apos;] = &apos;&apos;;
    msg[&apos;OBX&apos;][&apos;OBX.24&apos;][&apos;OBX.24.4&apos;] = &apos;&apos;;
    msg[&apos;OBX&apos;][&apos;OBX.24&apos;][&apos;OBX.24.5&apos;] = &apos;&apos;;
  }
}
catch(e)
{
  logger.error(&quot;Error in Store transformed message to file Transformer: ORU R01 2.3.1 to 2.5.1 Transformation: &quot; + e.message);
  channelMap.put(&apos;componentErrors&apos;,  $(&apos;componentErrors&apos;) + &quot;Store transformed message to file Transformer: ORU R01 2.3.1 to 2.5.1 Transformation: \n&quot; + e.message + &quot; |\n&quot;);
}</script>
            <type>JavaScript</type>
            <data class="map">
              <entry>
                <string>Script</string>
                <string>try
{
  // 2.3.1 to 2.5.1 ORU R01-specific MSH transformations
  if ( ($(&apos;translateToVersion&apos;) == &apos;2.5.1&apos;) &amp;&amp;
       ($(&apos;msgType&apos;) == &apos;ORU&apos;) &amp;&amp;
       ($(&apos;msgTriggerEvent&apos;) == &apos;R01&apos;) &amp;&amp;
       ($(&apos;msgHL7VersionID&apos;) == &apos;2.3.1&apos;) )
  {
    logger.info(&quot;Transforming ORU R01 2.3.1 message to 2.5.1&quot;);

    // MSH additions
    msg[&apos;MSH&apos;][&apos;MSH.12&apos;] = &apos;2.5.1&apos;;&#xd;
    msg[&apos;MSH&apos;][&apos;MSH.9&apos;][&apos;MSH.9.3&apos;] = &apos;ORU_R01&apos;;&#xd;
    msg[&apos;MSH&apos;][&apos;MSH.21&apos;][&apos;MSH.21.1&apos;] = &apos;V251_IG_LB_LABRPTPH_R1_INFORM_2010FEB&apos;;
    msg[&apos;MSH&apos;][&apos;MSH.21&apos;][&apos;MSH.21.2&apos;] = &apos;&apos;;
    msg[&apos;MSH&apos;][&apos;MSH.21&apos;][&apos;MSH.21.3&apos;] = &apos;2.16.840.1.114222.4.3.2.5.2.5&apos;;
    msg[&apos;MSH&apos;][&apos;MSH.21&apos;][&apos;MSH.21.4&apos;] = &apos;ISO&apos;;

    // OBR deletions
    msg[&apos;OBR&apos;][&apos;OBR.14&apos;] = &apos;&apos;;
    msg[&apos;OBR&apos;][&apos;OBR.15&apos;] = &apos;&apos;;

    // OBX additions
    msg[&apos;OBX&apos;][&apos;OBX.23&apos;] = &quot;INFORMATION NOT AVAILABLE&quot;;
    msg[&apos;OBX&apos;][&apos;OBX.24&apos;][&apos;OBX.24.1&apos;] = &quot;INFORMATION NOT AVAILABLE&quot;;
    msg[&apos;OBX&apos;][&apos;OBX.24&apos;][&apos;OBX.24.2&apos;] = &apos;&apos;;
    msg[&apos;OBX&apos;][&apos;OBX.24&apos;][&apos;OBX.24.3&apos;] = &apos;&apos;;
    msg[&apos;OBX&apos;][&apos;OBX.24&apos;][&apos;OBX.24.4&apos;] = &apos;&apos;;
    msg[&apos;OBX&apos;][&apos;OBX.24&apos;][&apos;OBX.24.5&apos;] = &apos;&apos;;
  }
}
catch(e)
{
  logger.error(&quot;Error in Store transformed message to file Transformer: ORU R01 2.3.1 to 2.5.1 Transformation: &quot; + e.message);
  channelMap.put(&apos;componentErrors&apos;,  $(&apos;componentErrors&apos;) + &quot;Store transformed message to file Transformer: ORU R01 2.3.1 to 2.5.1 Transformation: \n&quot; + e.message + &quot; |\n&quot;);
}</string>
              </entry>
            </data>
          </step>
        </steps>
        <inboundTemplate encoding="base64"></inboundTemplate>
        <outboundTemplate encoding="base64"></outboundTemplate>
        <inboundProtocol>HL7V2</inboundProtocol>
        <outboundProtocol>HL7V2</outboundProtocol>
        <inboundProperties>
          <property name="convertLFtoCR">true</property>
          <property name="handleRepetitions">false</property>
          <property name="handleSubcomponents">false</property>
          <property name="stripNamespaces">true</property>
          <property name="useStrictParser">false</property>
          <property name="useStrictValidation">false</property>
        </inboundProperties>
        <outboundProperties>
          <property name="convertLFtoCR">true</property>
          <property name="handleRepetitions">false</property>
          <property name="handleSubcomponents">false</property>
          <property name="stripNamespaces">true</property>
          <property name="useStrictParser">false</property>
          <property name="useStrictValidation">false</property>
        </outboundProperties>
      </transformer>
      <filter>
        <rules>
          <rule>
            <sequenceNumber>0</sequenceNumber>
            <name>Filter destination based on prior errors</name>
            <data class="map">
              <entry>
                <string>Script</string>
                <string>return ($(&apos;componentErrors&apos;).length() == 0 &amp;&amp;
        $(&apos;hubHost&apos;) == $(&apos;receivingFacilityHubHost&apos;));</string>
              </entry>
            </data>
            <type>JavaScript</type>
            <script>return ($(&apos;componentErrors&apos;).length() == 0 &amp;&amp;
        $(&apos;hubHost&apos;) == $(&apos;receivingFacilityHubHost&apos;));</script>
            <operator>NONE</operator>
          </rule>
        </rules>
      </filter>
      <transportName>File Writer</transportName>
      <mode>DESTINATION</mode>
      <enabled>true</enabled>
      <version>2.2.0.5828</version>
    </connector>
    <connector>
      <name>Send msg to Receiving Facility WS (to PHIX1)</name>
      <properties>
        <property name="DataType">Web Service Sender</property>
        <property name="dispatcherAttachmentContents">&lt;list/&gt;</property>
        <property name="dispatcherAttachmentNames">&lt;list/&gt;</property>
        <property name="dispatcherAttachmentTypes">&lt;list/&gt;</property>
        <property name="dispatcherEnvelope">&lt;soapenv:Envelope xmlns:ns=&quot;http://ws.connectors.connect.mirth.com/&quot; xmlns:soapenv=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;&gt;&#xd;
  &lt;soapenv:Header/&gt;&#xd;
  &lt;soapenv:Body&gt;&#xd;
    &lt;ns:acceptMessage&gt;&#xd;
      &lt;arg0&gt;&lt;![CDATA[${message.encodedData}]]&gt;&lt;/arg0&gt;
    &lt;/ns:acceptMessage&gt;&#xd;
  &lt;/soapenv:Body&gt;
&lt;/soapenv:Envelope&gt;&#xd;
</property>
        <property name="dispatcherOneWay">0</property>
        <property name="dispatcherOperation">acceptMessage</property>
        <property name="dispatcherPassword"></property>
        <property name="dispatcherPort">{http://ws.connectors.connect.mirth.com/}DefaultAcceptMessagePort</property>
        <property name="dispatcherReplyChannelId">sink</property>
        <property name="dispatcherService">{http://ws.connectors.connect.mirth.com/}DefaultAcceptMessageService</property>
        <property name="dispatcherSoapAction"></property>
        <property name="dispatcherUseAuthentication">0</property>
        <property name="dispatcherUseMtom">0</property>
        <property name="dispatcherUsername"></property>
        <property name="dispatcherWsdlCacheId"></property>
        <property name="dispatcherWsdlOperations">&lt;list&gt;
  &lt;string&gt;acceptMessage&lt;/string&gt;
&lt;/list&gt;</property>
        <property name="dispatcherWsdlUrl">http://atlphix01.dhcp.saic.com:8081/services/Mirth?wsdl</property>
        <property name="host">atlphix01.dhcp.saic.com:8081/services/Mirth?wsdl</property>
        <property name="queuePollInterval">200</property>
        <property name="reconnectMillisecs">10000</property>
        <property name="rotateQueue">0</property>
        <property name="usePersistentQueues">0</property>
      </properties>
      <transformer>
        <steps>
          <step>
            <sequenceNumber>0</sequenceNumber>
            <name>Perform anonymization</name>
            <script>try
{
  if ($(&apos;anonymization&apos;) == &apos;true&apos;)
  {
    logger.info(&quot;Performing anonymization&quot;);

    // Insert bioSensePatientId generated by the BioSenseLinker service
    msg[&apos;PID&apos;][&apos;PID.3&apos;][&apos;PID.3.1&apos;] = $(&apos;bioSensePatientId&apos;) + &apos;&apos;;

    msg[&apos;PID&apos;][&apos;PID.3&apos;][&apos;PID.3.4&apos;] = &quot;&amp;2.16.840.1.114222.4.3.2.5.2.2&amp;ISO&quot;;

    // anonymize all patient name values except PID-5.7: Name Type Code
    msg[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.1&apos;] = &apos;&apos;;
    msg[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.2&apos;] = &apos;&apos;;
    msg[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.3&apos;] = &apos;&apos;;
    msg[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.4&apos;] = &apos;&apos;;
    msg[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.5&apos;] = &apos;&apos;;
    msg[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.6&apos;] = &apos;&apos;;
  
    // remove day from DOB
    var dob = msg[&apos;PID&apos;][&apos;PID.7&apos;][&apos;PID.7.1&apos;].toString();

    if (dob.length &gt;= 6)
    {
      dob = dob.substring(0, 6);
      msg[&apos;PID&apos;][&apos;PID.7&apos;][&apos;PID.7.1&apos;] = dob;
    }

    // anonymize street address
    msg[&apos;PID&apos;][&apos;PID.11&apos;][&apos;PID.11.1&apos;] = &apos;&apos;;

    // anonymize other designation
    msg[&apos;PID&apos;][&apos;PID.11&apos;][&apos;PID.11.2&apos;] = &apos;&apos;;

    // anonymize city
    msg[&apos;PID&apos;][&apos;PID.11&apos;][&apos;PID.11.3&apos;] = &apos;&apos;;

    // anonymize address type
    msg[&apos;PID&apos;][&apos;PID.11&apos;][&apos;PID.11.7&apos;] = &apos;&apos;;

    // anonymize other geographic designation
    msg[&apos;PID&apos;][&apos;PID.11&apos;][&apos;PID.11.8&apos;] = &apos;&apos;;

    // Insert bioSenseVisitId generated by the BioSenseLinker service&#xd;    msg[&apos;PV1&apos;][&apos;PV1.19&apos;][&apos;PV1.19.1&apos;] = $(&apos;bioSenseVisitId&apos;) + &apos;&apos;;

    msg[&apos;PV1&apos;][&apos;PV1.19&apos;][&apos;PV1.19.4&apos;] = &quot;&amp;2.16.840.1.114222.4.3.2.5.2.2&amp;ISO&quot;;
  }
}
catch(e)
{
  logger.error(&quot;Error in Send msg to Receiving Facility Transformer: &quot; + e.message);
  channelMap.put(&apos;componentErrors&apos;,  $(&apos;componentErrors&apos;) + &quot;Send msg to Receiving Facility Transformer: \n&quot; + e.message + &quot; |\n&quot;);
}</script>
            <type>JavaScript</type>
            <data class="map">
              <entry>
                <string>Script</string>
                <string>try
{
  if ($(&apos;anonymization&apos;) == &apos;true&apos;)
  {
    logger.info(&quot;Performing anonymization&quot;);

    // Insert bioSensePatientId generated by the BioSenseLinker service
    msg[&apos;PID&apos;][&apos;PID.3&apos;][&apos;PID.3.1&apos;] = $(&apos;bioSensePatientId&apos;) + &apos;&apos;;

    msg[&apos;PID&apos;][&apos;PID.3&apos;][&apos;PID.3.4&apos;] = &quot;&amp;2.16.840.1.114222.4.3.2.5.2.2&amp;ISO&quot;;

    // anonymize all patient name values except PID-5.7: Name Type Code
    msg[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.1&apos;] = &apos;&apos;;
    msg[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.2&apos;] = &apos;&apos;;
    msg[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.3&apos;] = &apos;&apos;;
    msg[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.4&apos;] = &apos;&apos;;
    msg[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.5&apos;] = &apos;&apos;;
    msg[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.6&apos;] = &apos;&apos;;
  
    // remove day from DOB
    var dob = msg[&apos;PID&apos;][&apos;PID.7&apos;][&apos;PID.7.1&apos;].toString();

    if (dob.length &gt;= 6)
    {
      dob = dob.substring(0, 6);
      msg[&apos;PID&apos;][&apos;PID.7&apos;][&apos;PID.7.1&apos;] = dob;
    }

    // anonymize street address
    msg[&apos;PID&apos;][&apos;PID.11&apos;][&apos;PID.11.1&apos;] = &apos;&apos;;

    // anonymize other designation
    msg[&apos;PID&apos;][&apos;PID.11&apos;][&apos;PID.11.2&apos;] = &apos;&apos;;

    // anonymize city
    msg[&apos;PID&apos;][&apos;PID.11&apos;][&apos;PID.11.3&apos;] = &apos;&apos;;

    // anonymize address type
    msg[&apos;PID&apos;][&apos;PID.11&apos;][&apos;PID.11.7&apos;] = &apos;&apos;;

    // anonymize other geographic designation
    msg[&apos;PID&apos;][&apos;PID.11&apos;][&apos;PID.11.8&apos;] = &apos;&apos;;

    // Insert bioSenseVisitId generated by the BioSenseLinker service&#xd;    msg[&apos;PV1&apos;][&apos;PV1.19&apos;][&apos;PV1.19.1&apos;] = $(&apos;bioSenseVisitId&apos;) + &apos;&apos;;

    msg[&apos;PV1&apos;][&apos;PV1.19&apos;][&apos;PV1.19.4&apos;] = &quot;&amp;2.16.840.1.114222.4.3.2.5.2.2&amp;ISO&quot;;
  }
}
catch(e)
{
  logger.error(&quot;Error in Send msg to Receiving Facility Transformer: &quot; + e.message);
  channelMap.put(&apos;componentErrors&apos;,  $(&apos;componentErrors&apos;) + &quot;Send msg to Receiving Facility Transformer: \n&quot; + e.message + &quot; |\n&quot;);
}</string>
              </entry>
            </data>
          </step>
        </steps>
        <inboundTemplate encoding="base64"></inboundTemplate>
        <outboundTemplate encoding="base64"></outboundTemplate>
        <inboundProtocol>HL7V2</inboundProtocol>
        <outboundProtocol>HL7V2</outboundProtocol>
        <inboundProperties>
          <property name="convertLFtoCR">true</property>
          <property name="handleRepetitions">false</property>
          <property name="handleSubcomponents">false</property>
          <property name="stripNamespaces">true</property>
          <property name="useStrictParser">false</property>
          <property name="useStrictValidation">false</property>
        </inboundProperties>
        <outboundProperties>
          <property name="convertLFtoCR">true</property>
          <property name="handleRepetitions">false</property>
          <property name="handleSubcomponents">false</property>
          <property name="stripNamespaces">true</property>
          <property name="useStrictParser">false</property>
          <property name="useStrictValidation">false</property>
        </outboundProperties>
      </transformer>
      <filter>
        <rules>
          <rule>
            <sequenceNumber>0</sequenceNumber>
            <name>filter to determine if msg needs to be sent to destination facility over Mirth WS</name>
            <data class="map">
              <entry>
                <string>Script</string>
                <string>var retval = false;

// Unfortunately, this version of Mirth does not seem to support variables inside web service endpoint URLs.
// This outermost conditional filters for phix1.phiresearchlab.org:8081 (PHIX 1) specifically (shouldn&apos;t be necessary).
if ($(&apos;receivingFacilityWebSvcHost&apos;) == &apos;atlphix01.dhcp.saic.com:8081&apos;)
{

  if ($(&apos;receivingFacilityXportType&apos;) == &apos;MIRTH_WS&apos;)
  {
    if ($(&apos;hubHost&apos;) != $(&apos;receivingFacilityHubHost&apos;))
    {
      if ($(&apos;componentErrors&apos;).length() &gt; 0)
      {
        logger.info(&quot;Bypassing Send msg to Receiving Facility because of prior errors: &quot; + $(&apos;componentErrors&apos;));
      }
      else
      {
        logger.info(&quot;Sending msg to Receiving Facility: &quot; + $(&apos;receivingFacilityWebSvcHost&apos;));
        retval = true;
      }
    }
    else
    {
      logger.info(&quot;Msg is currently at Receiving Facility; no need to send.&quot;);
    }
  }
  
}

if (retval)
{
  channelMap.put(&apos;outgoingMsgSentStatus&apos;, &apos;SENT VIA WS&apos;);
}
else
{
  channelMap.put(&apos;outgoingMsgSentStatus&apos;, &apos;BYPASSED&apos;);
}

return retval;</string>
              </entry>
            </data>
            <type>JavaScript</type>
            <script>var retval = false;

// Unfortunately, this version of Mirth does not seem to support variables inside web service endpoint URLs.
// This outermost conditional filters for phix1.phiresearchlab.org:8081 (PHIX 1) specifically (shouldn&apos;t be necessary).
if ($(&apos;receivingFacilityWebSvcHost&apos;) == &apos;atlphix01.dhcp.saic.com:8081&apos;)
{

  if ($(&apos;receivingFacilityXportType&apos;) == &apos;MIRTH_WS&apos;)
  {
    if ($(&apos;hubHost&apos;) != $(&apos;receivingFacilityHubHost&apos;))
    {
      if ($(&apos;componentErrors&apos;).length() &gt; 0)
      {
        logger.info(&quot;Bypassing Send msg to Receiving Facility because of prior errors: &quot; + $(&apos;componentErrors&apos;));
      }
      else
      {
        logger.info(&quot;Sending msg to Receiving Facility: &quot; + $(&apos;receivingFacilityWebSvcHost&apos;));
        retval = true;
      }
    }
    else
    {
      logger.info(&quot;Msg is currently at Receiving Facility; no need to send.&quot;);
    }
  }
  
}

if (retval)
{
  channelMap.put(&apos;outgoingMsgSentStatus&apos;, &apos;SENT VIA WS&apos;);
}
else
{
  channelMap.put(&apos;outgoingMsgSentStatus&apos;, &apos;BYPASSED&apos;);
}

return retval;</script>
            <operator>NONE</operator>
          </rule>
        </rules>
      </filter>
      <transportName>Web Service Sender</transportName>
      <mode>DESTINATION</mode>
      <enabled>true</enabled>
      <version>2.2.0.5828</version>
    </connector>
    <connector>
      <name>Send msg to Receiving Facility WS (to PHIX2)</name>
      <properties>
        <property name="DataType">Web Service Sender</property>
        <property name="dispatcherAttachmentContents">&lt;list/&gt;</property>
        <property name="dispatcherAttachmentNames">&lt;list/&gt;</property>
        <property name="dispatcherAttachmentTypes">&lt;list/&gt;</property>
        <property name="dispatcherEnvelope">&lt;soapenv:Envelope xmlns:ns=&quot;http://ws.connectors.connect.mirth.com/&quot; xmlns:soapenv=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;&gt;&#xd;
  &lt;soapenv:Header/&gt;&#xd;
  &lt;soapenv:Body&gt;&#xd;
    &lt;ns:acceptMessage&gt;&#xd;
      &lt;arg0&gt;&lt;![CDATA[${message.encodedData}]]&gt;&lt;/arg0&gt;
    &lt;/ns:acceptMessage&gt;&#xd;
  &lt;/soapenv:Body&gt;
&lt;/soapenv:Envelope&gt;&#xd;
</property>
        <property name="dispatcherOneWay">0</property>
        <property name="dispatcherOperation">acceptMessage</property>
        <property name="dispatcherPassword"></property>
        <property name="dispatcherPort">{http://ws.connectors.connect.mirth.com/}DefaultAcceptMessagePort</property>
        <property name="dispatcherReplyChannelId">sink</property>
        <property name="dispatcherService">{http://ws.connectors.connect.mirth.com/}DefaultAcceptMessageService</property>
        <property name="dispatcherSoapAction"></property>
        <property name="dispatcherUseAuthentication">0</property>
        <property name="dispatcherUseMtom">0</property>
        <property name="dispatcherUsername"></property>
        <property name="dispatcherWsdlCacheId"></property>
        <property name="dispatcherWsdlOperations">&lt;list&gt;
  &lt;string&gt;acceptMessage&lt;/string&gt;
&lt;/list&gt;</property>
        <property name="dispatcherWsdlUrl">http://atlphix02.dhcp.saic.com:8081/services/Mirth?wsdl</property>
        <property name="host">atlphix02.dhcp.saic.com:8081/services/Mirth?wsdl</property>
        <property name="queuePollInterval">200</property>
        <property name="reconnectMillisecs">10000</property>
        <property name="rotateQueue">0</property>
        <property name="usePersistentQueues">0</property>
      </properties>
      <transformer>
        <steps>
          <step>
            <sequenceNumber>0</sequenceNumber>
            <name>Perform anonymization</name>
            <script>try
{
  if ($(&apos;anonymization&apos;) == &apos;true&apos;)
  {
    logger.info(&quot;Performing anonymization&quot;);

    // Insert bioSensePatientId generated by the BioSenseLinker service
    msg[&apos;PID&apos;][&apos;PID.3&apos;][&apos;PID.3.1&apos;] = $(&apos;bioSensePatientId&apos;) + &apos;&apos;;

    msg[&apos;PID&apos;][&apos;PID.3&apos;][&apos;PID.3.4&apos;] = &quot;&amp;2.16.840.1.114222.4.3.2.5.2.2&amp;ISO&quot;;

    // anonymize all patient name values except PID-5.7: Name Type Code
    msg[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.1&apos;] = &apos;&apos;;
    msg[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.2&apos;] = &apos;&apos;;
    msg[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.3&apos;] = &apos;&apos;;
    msg[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.4&apos;] = &apos;&apos;;
    msg[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.5&apos;] = &apos;&apos;;
    msg[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.6&apos;] = &apos;&apos;;
  
    // remove day from DOB
    var dob = msg[&apos;PID&apos;][&apos;PID.7&apos;][&apos;PID.7.1&apos;].toString();

    if (dob.length &gt;= 6)
    {
      dob = dob.substring(0, 6);
      msg[&apos;PID&apos;][&apos;PID.7&apos;][&apos;PID.7.1&apos;] = dob;
    }

    // anonymize street address
    msg[&apos;PID&apos;][&apos;PID.11&apos;][&apos;PID.11.1&apos;] = &apos;&apos;;

    // anonymize other designation
    msg[&apos;PID&apos;][&apos;PID.11&apos;][&apos;PID.11.2&apos;] = &apos;&apos;;

    // anonymize city
    msg[&apos;PID&apos;][&apos;PID.11&apos;][&apos;PID.11.3&apos;] = &apos;&apos;;

    // anonymize address type
    msg[&apos;PID&apos;][&apos;PID.11&apos;][&apos;PID.11.7&apos;] = &apos;&apos;;

    // anonymize other geographic designation
    msg[&apos;PID&apos;][&apos;PID.11&apos;][&apos;PID.11.8&apos;] = &apos;&apos;;

    // Insert bioSenseVisitId generated by the BioSenseLinker service&#xd;    msg[&apos;PV1&apos;][&apos;PV1.19&apos;][&apos;PV1.19.1&apos;] = $(&apos;bioSenseVisitId&apos;) + &apos;&apos;;

    msg[&apos;PV1&apos;][&apos;PV1.19&apos;][&apos;PV1.19.4&apos;] = &quot;&amp;2.16.840.1.114222.4.3.2.5.2.2&amp;ISO&quot;;
  }
}
catch(e)
{
  logger.error(&quot;Error in Send msg to Receiving Facility Transformer: &quot; + e.message);
  channelMap.put(&apos;componentErrors&apos;,  $(&apos;componentErrors&apos;) + &quot;Send msg to Receiving Facility Transformer: \n&quot; + e.message + &quot; |\n&quot;);
}</script>
            <type>JavaScript</type>
            <data class="map">
              <entry>
                <string>Script</string>
                <string>try
{
  if ($(&apos;anonymization&apos;) == &apos;true&apos;)
  {
    logger.info(&quot;Performing anonymization&quot;);

    // Insert bioSensePatientId generated by the BioSenseLinker service
    msg[&apos;PID&apos;][&apos;PID.3&apos;][&apos;PID.3.1&apos;] = $(&apos;bioSensePatientId&apos;) + &apos;&apos;;

    msg[&apos;PID&apos;][&apos;PID.3&apos;][&apos;PID.3.4&apos;] = &quot;&amp;2.16.840.1.114222.4.3.2.5.2.2&amp;ISO&quot;;

    // anonymize all patient name values except PID-5.7: Name Type Code
    msg[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.1&apos;] = &apos;&apos;;
    msg[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.2&apos;] = &apos;&apos;;
    msg[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.3&apos;] = &apos;&apos;;
    msg[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.4&apos;] = &apos;&apos;;
    msg[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.5&apos;] = &apos;&apos;;
    msg[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.6&apos;] = &apos;&apos;;
  
    // remove day from DOB
    var dob = msg[&apos;PID&apos;][&apos;PID.7&apos;][&apos;PID.7.1&apos;].toString();

    if (dob.length &gt;= 6)
    {
      dob = dob.substring(0, 6);
      msg[&apos;PID&apos;][&apos;PID.7&apos;][&apos;PID.7.1&apos;] = dob;
    }

    // anonymize street address
    msg[&apos;PID&apos;][&apos;PID.11&apos;][&apos;PID.11.1&apos;] = &apos;&apos;;

    // anonymize other designation
    msg[&apos;PID&apos;][&apos;PID.11&apos;][&apos;PID.11.2&apos;] = &apos;&apos;;

    // anonymize city
    msg[&apos;PID&apos;][&apos;PID.11&apos;][&apos;PID.11.3&apos;] = &apos;&apos;;

    // anonymize address type
    msg[&apos;PID&apos;][&apos;PID.11&apos;][&apos;PID.11.7&apos;] = &apos;&apos;;

    // anonymize other geographic designation
    msg[&apos;PID&apos;][&apos;PID.11&apos;][&apos;PID.11.8&apos;] = &apos;&apos;;

    // Insert bioSenseVisitId generated by the BioSenseLinker service&#xd;    msg[&apos;PV1&apos;][&apos;PV1.19&apos;][&apos;PV1.19.1&apos;] = $(&apos;bioSenseVisitId&apos;) + &apos;&apos;;

    msg[&apos;PV1&apos;][&apos;PV1.19&apos;][&apos;PV1.19.4&apos;] = &quot;&amp;2.16.840.1.114222.4.3.2.5.2.2&amp;ISO&quot;;
  }
}
catch(e)
{
  logger.error(&quot;Error in Send msg to Receiving Facility Transformer: &quot; + e.message);
  channelMap.put(&apos;componentErrors&apos;,  $(&apos;componentErrors&apos;) + &quot;Send msg to Receiving Facility Transformer: \n&quot; + e.message + &quot; |\n&quot;);
}</string>
              </entry>
            </data>
          </step>
        </steps>
        <inboundTemplate encoding="base64"></inboundTemplate>
        <outboundTemplate encoding="base64"></outboundTemplate>
        <inboundProtocol>HL7V2</inboundProtocol>
        <outboundProtocol>HL7V2</outboundProtocol>
        <inboundProperties>
          <property name="convertLFtoCR">true</property>
          <property name="handleRepetitions">false</property>
          <property name="handleSubcomponents">false</property>
          <property name="stripNamespaces">true</property>
          <property name="useStrictParser">false</property>
          <property name="useStrictValidation">false</property>
        </inboundProperties>
        <outboundProperties>
          <property name="convertLFtoCR">true</property>
          <property name="handleRepetitions">false</property>
          <property name="handleSubcomponents">false</property>
          <property name="stripNamespaces">true</property>
          <property name="useStrictParser">false</property>
          <property name="useStrictValidation">false</property>
        </outboundProperties>
      </transformer>
      <filter>
        <rules>
          <rule>
            <sequenceNumber>0</sequenceNumber>
            <name>filter to determine if msg needs to be sent to destination facility over Mirth WS</name>
            <data class="map">
              <entry>
                <string>Script</string>
                <string>var retval = false;

// Unfortunately, this version of Mirth does not seem to support variables inside web service endpoint URLs.
// This outermost conditional filters for phix2.phiresearchlab.org:8081 (PHIX 2) specifically (shouldn&apos;t be necessary).
if ($(&apos;receivingFacilityWebSvcHost&apos;) == &apos;atlphix02.dhcp.saic.com:8081&apos;)
{

  if ($(&apos;receivingFacilityXportType&apos;) == &apos;MIRTH_WS&apos;)
  {
    if ($(&apos;hubHost&apos;) != $(&apos;receivingFacilityHubHost&apos;))
    {
      if ($(&apos;componentErrors&apos;).length() &gt; 0)
      {
        logger.info(&quot;Bypassing Send msg to Receiving Facility because of prior errors: &quot; + $(&apos;componentErrors&apos;));
      }
      else
      {
        logger.info(&quot;Sending msg to Receiving Facility: &quot; + $(&apos;receivingFacilityWebSvcHost&apos;));
        retval = true;
      }
    }
    else
    {
      logger.info(&quot;Msg is currently at Receiving Facility; no need to send.&quot;);
    }
  }

}

if (retval)
{
  channelMap.put(&apos;outgoingMsgSentStatus&apos;, &apos;SENT VIA WS&apos;);
}
else
{
  channelMap.put(&apos;outgoingMsgSentStatus&apos;, &apos;BYPASSED&apos;);
}

return retval;</string>
              </entry>
            </data>
            <type>JavaScript</type>
            <script>var retval = false;

// Unfortunately, this version of Mirth does not seem to support variables inside web service endpoint URLs.
// This outermost conditional filters for phix2.phiresearchlab.org:8081 (PHIX 2) specifically (shouldn&apos;t be necessary).
if ($(&apos;receivingFacilityWebSvcHost&apos;) == &apos;atlphix02.dhcp.saic.com:8081&apos;)
{

  if ($(&apos;receivingFacilityXportType&apos;) == &apos;MIRTH_WS&apos;)
  {
    if ($(&apos;hubHost&apos;) != $(&apos;receivingFacilityHubHost&apos;))
    {
      if ($(&apos;componentErrors&apos;).length() &gt; 0)
      {
        logger.info(&quot;Bypassing Send msg to Receiving Facility because of prior errors: &quot; + $(&apos;componentErrors&apos;));
      }
      else
      {
        logger.info(&quot;Sending msg to Receiving Facility: &quot; + $(&apos;receivingFacilityWebSvcHost&apos;));
        retval = true;
      }
    }
    else
    {
      logger.info(&quot;Msg is currently at Receiving Facility; no need to send.&quot;);
    }
  }

}

if (retval)
{
  channelMap.put(&apos;outgoingMsgSentStatus&apos;, &apos;SENT VIA WS&apos;);
}
else
{
  channelMap.put(&apos;outgoingMsgSentStatus&apos;, &apos;BYPASSED&apos;);
}

return retval;</script>
            <operator>NONE</operator>
          </rule>
        </rules>
      </filter>
      <transportName>Web Service Sender</transportName>
      <mode>DESTINATION</mode>
      <enabled>true</enabled>
      <version>2.2.0.5828</version>
    </connector>
    <connector>
      <name>Send msg to Receiving Facility (NHIN DIRECT REST)</name>
      <properties>
        <property name="DataType">JavaScript Writer</property>
        <property name="host">sink</property>
        <property name="script">var sndr = new Packages.gov.cdc.phlissa.hub.direct.HubDirectSender();
var subject = &quot;HL7 Message - &quot; + messageObject.getSource().toString();
var toAddress = $(&apos;receivingFacilityDirectEmailAddress&apos;);

var lname = sndr.getLogName();

logger.info(lname + &quot; - Host: &quot; + sndr.getHost() );
logger.info(lname + &quot; - Port: &quot; + sndr.getPort() );
logger.info(lname + &quot; - From: &quot; + sndr.getFromAddress() );
logger.info(lname + &quot; - To: &quot; + toAddress);
logger.info(lname + &quot; - Subject: &quot; + subject);
//logger.info(lname + &quot; - Trust store: &quot; + sndr.getTrustStorePath() );
//logger.info(lname + &quot; - Trust store password: &quot; + sndr.getTrustStorePassword() );

try
{
  sndr.sendDirectMessage(toAddress, subject, messageObject.getEncodedData().toString(), true);&#xd;

  logger.info(lname + &quot; - Message Location: &quot; + sndr.getLocation() );
  logger.info(lname + &quot; - Direct Response: &quot; + sndr.getResponse() );
}
catch(e)
{
  logger.info(lname + &quot; - Runtime exception: &quot; + e.message );
  channelMap.put(&apos;componentErrors&apos;,  $(&apos;componentErrors&apos;) + &quot;DIRECT Sender:\n&quot; + e.message + &quot;\n&quot;);

  var hasError = sndr.hasError();

  if (hasError) 
  {
    logger.info(lname + &quot; - Error Message: &quot; + sndr.getErrorMessage() );
    channelMap.put(&apos;componentErrors&apos;,  $(&apos;componentErrors&apos;) + &quot;DIRECT Sender:\n&quot; + sndr.getErrorMessage() + &quot;\n&quot;);
  }

}
</property>
      </properties>
      <transformer>
        <steps>
          <step>
            <sequenceNumber>0</sequenceNumber>
            <name>Perform anonymization</name>
            <script>try
{
  if ($(&apos;anonymization&apos;) == &apos;true&apos;)
  {
    logger.info(&quot;Performing anonymization&quot;);

    // Insert bioSensePatientId generated by the BioSenseLinker service
    msg[&apos;PID&apos;][&apos;PID.3&apos;][&apos;PID.3.1&apos;] = $(&apos;bioSensePatientId&apos;) + &apos;&apos;;

    msg[&apos;PID&apos;][&apos;PID.3&apos;][&apos;PID.3.4&apos;] = &quot;&amp;2.16.840.1.114222.4.3.2.5.2.2&amp;ISO&quot;;

    // anonymize all patient name values except PID-5.7: Name Type Code
    msg[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.1&apos;] = &apos;&apos;;
    msg[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.2&apos;] = &apos;&apos;;
    msg[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.3&apos;] = &apos;&apos;;
    msg[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.4&apos;] = &apos;&apos;;
    msg[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.5&apos;] = &apos;&apos;;
    msg[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.6&apos;] = &apos;&apos;;
  
    // remove day from DOB
    var dob = msg[&apos;PID&apos;][&apos;PID.7&apos;][&apos;PID.7.1&apos;].toString();

    if (dob.length &gt;= 6)
    {
      dob = dob.substring(0, 6);
      msg[&apos;PID&apos;][&apos;PID.7&apos;][&apos;PID.7.1&apos;] = dob;
    }

    // anonymize street address
    msg[&apos;PID&apos;][&apos;PID.11&apos;][&apos;PID.11.1&apos;] = &apos;&apos;;

    // anonymize other designation
    msg[&apos;PID&apos;][&apos;PID.11&apos;][&apos;PID.11.2&apos;] = &apos;&apos;;

    // anonymize city
    msg[&apos;PID&apos;][&apos;PID.11&apos;][&apos;PID.11.3&apos;] = &apos;&apos;;

    // anonymize address type
    msg[&apos;PID&apos;][&apos;PID.11&apos;][&apos;PID.11.7&apos;] = &apos;&apos;;

    // anonymize other geographic designation
    msg[&apos;PID&apos;][&apos;PID.11&apos;][&apos;PID.11.8&apos;] = &apos;&apos;;

    // Insert bioSenseVisitId generated by the BioSenseLinker service&#xd;    msg[&apos;PV1&apos;][&apos;PV1.19&apos;][&apos;PV1.19.1&apos;] = $(&apos;bioSenseVisitId&apos;) + &apos;&apos;;

    msg[&apos;PV1&apos;][&apos;PV1.19&apos;][&apos;PV1.19.4&apos;] = &quot;&amp;2.16.840.1.114222.4.3.2.5.2.2&amp;ISO&quot;;
  }
}
catch(e)
{
  logger.error(&quot;Error in Send msg to Receiving Facility Transformer: &quot; + e.message);
  channelMap.put(&apos;componentErrors&apos;,  $(&apos;componentErrors&apos;) + &quot;Send msg to Receiving Facility Transformer: \n&quot; + e.message + &quot; |\n&quot;);
}</script>
            <type>JavaScript</type>
            <data class="map">
              <entry>
                <string>Script</string>
                <string>try
{
  if ($(&apos;anonymization&apos;) == &apos;true&apos;)
  {
    logger.info(&quot;Performing anonymization&quot;);

    // Insert bioSensePatientId generated by the BioSenseLinker service
    msg[&apos;PID&apos;][&apos;PID.3&apos;][&apos;PID.3.1&apos;] = $(&apos;bioSensePatientId&apos;) + &apos;&apos;;

    msg[&apos;PID&apos;][&apos;PID.3&apos;][&apos;PID.3.4&apos;] = &quot;&amp;2.16.840.1.114222.4.3.2.5.2.2&amp;ISO&quot;;

    // anonymize all patient name values except PID-5.7: Name Type Code
    msg[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.1&apos;] = &apos;&apos;;
    msg[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.2&apos;] = &apos;&apos;;
    msg[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.3&apos;] = &apos;&apos;;
    msg[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.4&apos;] = &apos;&apos;;
    msg[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.5&apos;] = &apos;&apos;;
    msg[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.6&apos;] = &apos;&apos;;
  
    // remove day from DOB
    var dob = msg[&apos;PID&apos;][&apos;PID.7&apos;][&apos;PID.7.1&apos;].toString();

    if (dob.length &gt;= 6)
    {
      dob = dob.substring(0, 6);
      msg[&apos;PID&apos;][&apos;PID.7&apos;][&apos;PID.7.1&apos;] = dob;
    }

    // anonymize street address
    msg[&apos;PID&apos;][&apos;PID.11&apos;][&apos;PID.11.1&apos;] = &apos;&apos;;

    // anonymize other designation
    msg[&apos;PID&apos;][&apos;PID.11&apos;][&apos;PID.11.2&apos;] = &apos;&apos;;

    // anonymize city
    msg[&apos;PID&apos;][&apos;PID.11&apos;][&apos;PID.11.3&apos;] = &apos;&apos;;

    // anonymize address type
    msg[&apos;PID&apos;][&apos;PID.11&apos;][&apos;PID.11.7&apos;] = &apos;&apos;;

    // anonymize other geographic designation
    msg[&apos;PID&apos;][&apos;PID.11&apos;][&apos;PID.11.8&apos;] = &apos;&apos;;

    // Insert bioSenseVisitId generated by the BioSenseLinker service&#xd;    msg[&apos;PV1&apos;][&apos;PV1.19&apos;][&apos;PV1.19.1&apos;] = $(&apos;bioSenseVisitId&apos;) + &apos;&apos;;

    msg[&apos;PV1&apos;][&apos;PV1.19&apos;][&apos;PV1.19.4&apos;] = &quot;&amp;2.16.840.1.114222.4.3.2.5.2.2&amp;ISO&quot;;
  }
}
catch(e)
{
  logger.error(&quot;Error in Send msg to Receiving Facility Transformer: &quot; + e.message);
  channelMap.put(&apos;componentErrors&apos;,  $(&apos;componentErrors&apos;) + &quot;Send msg to Receiving Facility Transformer: \n&quot; + e.message + &quot; |\n&quot;);
}</string>
              </entry>
            </data>
          </step>
        </steps>
        <inboundTemplate encoding="base64"></inboundTemplate>
        <outboundTemplate encoding="base64"></outboundTemplate>
        <inboundProtocol>HL7V2</inboundProtocol>
        <outboundProtocol>HL7V2</outboundProtocol>
        <inboundProperties>
          <property name="convertLFtoCR">true</property>
          <property name="handleRepetitions">false</property>
          <property name="handleSubcomponents">false</property>
          <property name="stripNamespaces">true</property>
          <property name="useStrictParser">false</property>
          <property name="useStrictValidation">false</property>
        </inboundProperties>
        <outboundProperties>
          <property name="convertLFtoCR">true</property>
          <property name="handleRepetitions">false</property>
          <property name="handleSubcomponents">false</property>
          <property name="stripNamespaces">true</property>
          <property name="useStrictParser">false</property>
          <property name="useStrictValidation">false</property>
        </outboundProperties>
      </transformer>
      <filter>
        <rules>
          <rule>
            <sequenceNumber>0</sequenceNumber>
            <name>filter to determine if msg needs to be sent to destination facility over DIRECT REST</name>
            <data class="map">
              <entry>
                <string>Script</string>
                <string>var retval = false;

if ($(&apos;receivingFacilityXportType&apos;) == &apos;DIRECT&apos;)
{
  if ($(&apos;hubHost&apos;) != $(&apos;receivingFacilityHubHost&apos;))
  {
    if ($(&apos;componentErrors&apos;).length() &gt; 0)
    {
      logger.info(&quot;Bypassing Send msg via DIRECT REST to Receiving Facility because of prior errors: &quot; + $(&apos;componentErrors&apos;));
    }
    else
    {
      logger.info(&quot;Sending msg via DIRECT REST to Receiving Facility: &quot; + $(&apos;receivingFacilityDirectEmailAddress&apos;));
      retval = true;
    }
  }
  else
  {
    logger.info(&quot;Msg is currently at Receiving Facility; no need to send via DIRECT REST.&quot;);
  }
}

if (retval)
{
  channelMap.put(&apos;outgoingMsgSentStatus&apos;, &apos;SENT VIA DIRECT&apos;);
}
else
{
  channelMap.put(&apos;outgoingMsgSentStatus&apos;, &apos;BYPASSED&apos;);
}

return retval;</string>
              </entry>
            </data>
            <type>JavaScript</type>
            <script>var retval = false;

if ($(&apos;receivingFacilityXportType&apos;) == &apos;DIRECT&apos;)
{
  if ($(&apos;hubHost&apos;) != $(&apos;receivingFacilityHubHost&apos;))
  {
    if ($(&apos;componentErrors&apos;).length() &gt; 0)
    {
      logger.info(&quot;Bypassing Send msg via DIRECT REST to Receiving Facility because of prior errors: &quot; + $(&apos;componentErrors&apos;));
    }
    else
    {
      logger.info(&quot;Sending msg via DIRECT REST to Receiving Facility: &quot; + $(&apos;receivingFacilityDirectEmailAddress&apos;));
      retval = true;
    }
  }
  else
  {
    logger.info(&quot;Msg is currently at Receiving Facility; no need to send via DIRECT REST.&quot;);
  }
}

if (retval)
{
  channelMap.put(&apos;outgoingMsgSentStatus&apos;, &apos;SENT VIA DIRECT&apos;);
}
else
{
  channelMap.put(&apos;outgoingMsgSentStatus&apos;, &apos;BYPASSED&apos;);
}

return retval;</script>
            <operator>NONE</operator>
          </rule>
        </rules>
      </filter>
      <transportName>JavaScript Writer</transportName>
      <mode>DESTINATION</mode>
      <enabled>true</enabled>
      <version>2.2.0.5828</version>
    </connector>
    <connector>
      <name>Send result to PHIXConnectorService</name>
      <properties>
        <property name="DataType">Web Service Sender</property>
        <property name="dispatcherAttachmentContents">&lt;list/&gt;</property>
        <property name="dispatcherAttachmentNames">&lt;list/&gt;</property>
        <property name="dispatcherAttachmentTypes">&lt;list/&gt;</property>
        <property name="dispatcherEnvelope">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-16&quot;?&gt;
&lt;soap:Envelope xmlns:soap=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;
  &lt;soap:Body&gt;
    &lt;postResult xmlns=&quot;http://phix.cdc.gov/&quot;&gt;
      &lt;hl7Result xmlns=&quot;&quot;&gt;&lt;![CDATA[${message.encodedData}]]&gt;&lt;/hl7Result&gt;
      &lt;errors xmlns=&quot;&quot;&gt;&lt;![CDATA[${componentErrors}]]&gt;&lt;/errors&gt;
    &lt;/postResult&gt;
  &lt;/soap:Body&gt;
&lt;/soap:Envelope&gt;</property>
        <property name="dispatcherOneWay">0</property>
        <property name="dispatcherOperation">postResult</property>
        <property name="dispatcherPassword"></property>
        <property name="dispatcherPort">{http://phix.cdc.gov/}PHIXConnectorServicePort</property>
        <property name="dispatcherReplyChannelId">sink</property>
        <property name="dispatcherService">{http://phix.cdc.gov/}PHIXConnectorService</property>
        <property name="dispatcherSoapAction"></property>
        <property name="dispatcherUseAuthentication">0</property>
        <property name="dispatcherUseMtom">0</property>
        <property name="dispatcherUsername"></property>
        <property name="dispatcherWsdlCacheId"></property>
        <property name="dispatcherWsdlOperations">&lt;list&gt;
  &lt;string&gt;postMessage&lt;/string&gt;
  &lt;string&gt;postResult&lt;/string&gt;
&lt;/list&gt;</property>
        <property name="dispatcherWsdlUrl">http://phix1.phiresearchlab.org:8080/PHIXConnectorService/PHIXConnectorService?wsdl</property>
        <property name="host">phix1.phiresearchlab.org:8080/PHIXConnectorService/PHIXConnectorService?wsdl</property>
        <property name="queuePollInterval">200</property>
        <property name="reconnectMillisecs">10000</property>
        <property name="rotateQueue">0</property>
        <property name="usePersistentQueues">0</property>
      </properties>
      <transformer>
        <steps>
          <step>
            <sequenceNumber>0</sequenceNumber>
            <name>Apply Vocab Translation</name>
            <script>try
{
  // -- vocab translation --
  if ( $(&apos;stdObx31&apos;) != &apos;&apos; )
  {
    logger.info(&quot;Applying OBX.3 vocab translation to msg...&quot;);

    msg[&apos;OBX&apos;][&apos;OBX.3&apos;][&apos;OBX.3.1&apos;] = $(&apos;stdObx31&apos;);
    msg[&apos;OBX&apos;][&apos;OBX.3&apos;][&apos;OBX.3.2&apos;] = $(&apos;stdObx32&apos;);
    msg[&apos;OBX&apos;][&apos;OBX.3&apos;][&apos;OBX.3.3&apos;] = $(&apos;stdObx33&apos;);
  }

  if ( $(&apos;stdRxa51&apos;) != &apos;&apos; )
  {
    logger.info(&quot;Applying RXA.5 vocab translation to msg...&quot;);

    msg[&apos;RXA&apos;][&apos;RXA.5&apos;][&apos;RXA.5.1&apos;] = $(&apos;stdRxa51&apos;);
    msg[&apos;RXA&apos;][&apos;RXA.5&apos;][&apos;RXA.5.2&apos;] = $(&apos;stdRxa52&apos;);
    msg[&apos;RXA&apos;][&apos;RXA.5&apos;][&apos;RXA.5.3&apos;] = $(&apos;stdRxa53&apos;);
  }
}
catch(e)
{
  logger.error(&quot;Error in Send result to PHIXConnectorService Transformer: Apply Vocal Translation: &quot; + e.message);
  channelMap.put(&apos;componentErrors&apos;,  $(&apos;componentErrors&apos;) + &quot;Send result to PHIXConnectorService Transformer: Apply Vocal Translation: \n&quot; + e.message + &quot; |\n&quot;);
}</script>
            <type>JavaScript</type>
            <data class="map">
              <entry>
                <string>Script</string>
                <string>try
{
  // -- vocab translation --
  if ( $(&apos;stdObx31&apos;) != &apos;&apos; )
  {
    logger.info(&quot;Applying OBX.3 vocab translation to msg...&quot;);

    msg[&apos;OBX&apos;][&apos;OBX.3&apos;][&apos;OBX.3.1&apos;] = $(&apos;stdObx31&apos;);
    msg[&apos;OBX&apos;][&apos;OBX.3&apos;][&apos;OBX.3.2&apos;] = $(&apos;stdObx32&apos;);
    msg[&apos;OBX&apos;][&apos;OBX.3&apos;][&apos;OBX.3.3&apos;] = $(&apos;stdObx33&apos;);
  }

  if ( $(&apos;stdRxa51&apos;) != &apos;&apos; )
  {
    logger.info(&quot;Applying RXA.5 vocab translation to msg...&quot;);

    msg[&apos;RXA&apos;][&apos;RXA.5&apos;][&apos;RXA.5.1&apos;] = $(&apos;stdRxa51&apos;);
    msg[&apos;RXA&apos;][&apos;RXA.5&apos;][&apos;RXA.5.2&apos;] = $(&apos;stdRxa52&apos;);
    msg[&apos;RXA&apos;][&apos;RXA.5&apos;][&apos;RXA.5.3&apos;] = $(&apos;stdRxa53&apos;);
  }
}
catch(e)
{
  logger.error(&quot;Error in Send result to PHIXConnectorService Transformer: Apply Vocal Translation: &quot; + e.message);
  channelMap.put(&apos;componentErrors&apos;,  $(&apos;componentErrors&apos;) + &quot;Send result to PHIXConnectorService Transformer: Apply Vocal Translation: \n&quot; + e.message + &quot; |\n&quot;);
}</string>
              </entry>
            </data>
          </step>
          <step>
            <sequenceNumber>1</sequenceNumber>
            <name>Add SFT Segment</name>
            <script>try
{
  if ($(&apos;addSFTSegment&apos;) == &apos;true&apos;)
  {
    logger.info(&quot;Adding SFT Segment&quot;);

    // determine how many SFT segements already exist
    var i = 0;
  
    while(msg[&apos;SFT&apos;][i] != null) 
    {  
      ++i;
    }

    // create SFT segment, per requirements in &quot;Message Processing Flow&quot; spreadsheet
    var newSFT = createSegment(&apos;SFT&apos;);

    // workaround to put the new segment after the existing SFT, if another exists, otherwise after MSH
    if (i == 0)
    {
      msg[&apos;MSH&apos;] += newSFT;
    }
    else
    {
      msg[&apos;SFT&apos;] += newSFT;
    }

    msg[&apos;SFT&apos;][i][&apos;SFT.1&apos;][&apos;SFT.1.1&apos;] = &apos;PHIX&apos;;
    msg[&apos;SFT&apos;][i][&apos;SFT.1&apos;][&apos;SFT.1.2&apos;] = &apos;L&apos;;
    msg[&apos;SFT&apos;][i][&apos;SFT.1&apos;][&apos;SFT.1.6&apos;][&apos;SFT.1.6.1&apos;] = &apos;&apos;;
    msg[&apos;SFT&apos;][i][&apos;SFT.1&apos;][&apos;SFT.1.6&apos;][&apos;SFT.1.6.2&apos;] = &apos;2.16.840.1.114222.4.3.2.5.2.4000&apos;;
    msg[&apos;SFT&apos;][i][&apos;SFT.1&apos;][&apos;SFT.1.6&apos;][&apos;SFT.1.6.3&apos;] = &apos;ISO&apos;;
    msg[&apos;SFT&apos;][i][&apos;SFT.1&apos;][&apos;SFT.1.7&apos;] = &apos;XX&apos;;
    msg[&apos;SFT&apos;][i][&apos;SFT.1&apos;][&apos;SFT.1.10&apos;] = &apos;PHIX&apos;;

    msg[&apos;SFT&apos;][i][&apos;SFT.2&apos;] = &apos;1.3&apos;;
    msg[&apos;SFT&apos;][i][&apos;SFT.3&apos;] = &apos;PHIX&apos;;
    msg[&apos;SFT&apos;][i][&apos;SFT.4&apos;] = &apos;1.3&apos;;

    msg[&apos;SFT&apos;][i][&apos;SFT.6&apos;] = &apos;&apos;;
  }
}
catch(e)
{
  logger.error(&quot;Error in Send result to PHIXConnectorService Transformer: Add SFT Segment: &quot; + e.message);
  channelMap.put(&apos;componentErrors&apos;,  $(&apos;componentErrors&apos;) + &quot;Send result to PHIXConnectorService Transformer: Add SFT Segment: \n&quot; + e.message + &quot; |\n&quot;);
}</script>
            <type>JavaScript</type>
            <data class="map">
              <entry>
                <string>Script</string>
                <string>try
{
  if ($(&apos;addSFTSegment&apos;) == &apos;true&apos;)
  {
    logger.info(&quot;Adding SFT Segment&quot;);

    // determine how many SFT segements already exist
    var i = 0;
  
    while(msg[&apos;SFT&apos;][i] != null) 
    {  
      ++i;
    }

    // create SFT segment, per requirements in &quot;Message Processing Flow&quot; spreadsheet
    var newSFT = createSegment(&apos;SFT&apos;);

    // workaround to put the new segment after the existing SFT, if another exists, otherwise after MSH
    if (i == 0)
    {
      msg[&apos;MSH&apos;] += newSFT;
    }
    else
    {
      msg[&apos;SFT&apos;] += newSFT;
    }

    msg[&apos;SFT&apos;][i][&apos;SFT.1&apos;][&apos;SFT.1.1&apos;] = &apos;PHIX&apos;;
    msg[&apos;SFT&apos;][i][&apos;SFT.1&apos;][&apos;SFT.1.2&apos;] = &apos;L&apos;;
    msg[&apos;SFT&apos;][i][&apos;SFT.1&apos;][&apos;SFT.1.6&apos;][&apos;SFT.1.6.1&apos;] = &apos;&apos;;
    msg[&apos;SFT&apos;][i][&apos;SFT.1&apos;][&apos;SFT.1.6&apos;][&apos;SFT.1.6.2&apos;] = &apos;2.16.840.1.114222.4.3.2.5.2.4000&apos;;
    msg[&apos;SFT&apos;][i][&apos;SFT.1&apos;][&apos;SFT.1.6&apos;][&apos;SFT.1.6.3&apos;] = &apos;ISO&apos;;
    msg[&apos;SFT&apos;][i][&apos;SFT.1&apos;][&apos;SFT.1.7&apos;] = &apos;XX&apos;;
    msg[&apos;SFT&apos;][i][&apos;SFT.1&apos;][&apos;SFT.1.10&apos;] = &apos;PHIX&apos;;

    msg[&apos;SFT&apos;][i][&apos;SFT.2&apos;] = &apos;1.3&apos;;
    msg[&apos;SFT&apos;][i][&apos;SFT.3&apos;] = &apos;PHIX&apos;;
    msg[&apos;SFT&apos;][i][&apos;SFT.4&apos;] = &apos;1.3&apos;;

    msg[&apos;SFT&apos;][i][&apos;SFT.6&apos;] = &apos;&apos;;
  }
}
catch(e)
{
  logger.error(&quot;Error in Send result to PHIXConnectorService Transformer: Add SFT Segment: &quot; + e.message);
  channelMap.put(&apos;componentErrors&apos;,  $(&apos;componentErrors&apos;) + &quot;Send result to PHIXConnectorService Transformer: Add SFT Segment: \n&quot; + e.message + &quot; |\n&quot;);
}</string>
              </entry>
            </data>
          </step>
          <step>
            <sequenceNumber>2</sequenceNumber>
            <name>Add SPM Segment</name>
            <script>try
{
  if ($(&apos;addSPMSegment&apos;) == &apos;true&apos;)
  {
    logger.info(&quot;Adding SPM Segment&quot;);

    //var newSPM = createSegment(&apos;SPM&apos;);
    //msg[&apos;OBR&apos;] += newSPM;

    // Create SPM segment, per requirements in &quot;Message Processing Flow&quot; spreadsheet
    // (Not specifying a location should place it last, which is where it belongs)
  
    msg[&apos;SPM&apos;][&apos;SPM.1&apos;] = &apos;1&apos;;
    //msg[&apos;SPM&apos;][&apos;SPM.2&apos;][&apos;SPM.2.2&apos;][&apos;SPM.2.2.1&apos;] = msg[&apos;OBR&apos;][&apos;OBR.3&apos;][&apos;OBR.3.1&apos;];
    //msg[&apos;SPM&apos;][&apos;SPM.2&apos;][&apos;SPM.2.2&apos;][&apos;SPM.2.2.2&apos;] = msg[&apos;OBR&apos;][&apos;OBR.3&apos;][&apos;OBR.3.2&apos;];
    //msg[&apos;SPM&apos;][&apos;SPM.2&apos;][&apos;SPM.2.2&apos;][&apos;SPM.2.2.3&apos;] = msg[&apos;OBR&apos;][&apos;OBR.3&apos;][&apos;OBR.3.3&apos;];
    //msg[&apos;SPM&apos;][&apos;SPM.2&apos;][&apos;SPM.2.2&apos;][&apos;SPM.2.2.4&apos;] = msg[&apos;OBR&apos;][&apos;OBR.3&apos;][&apos;OBR.3.4&apos;];

    msg[&apos;SPM&apos;][&apos;SPM.2&apos;][&apos;SPM.2.2&apos;] = msg[&apos;OBR&apos;][&apos;OBR.3&apos;][&apos;OBR.3.1&apos;].toString() + &quot;&amp;&quot; +
                                     msg[&apos;OBR&apos;][&apos;OBR.3&apos;][&apos;OBR.3.2&apos;].toString() + &quot;&amp;&quot; +
                                     msg[&apos;OBR&apos;][&apos;OBR.3&apos;][&apos;OBR.3.3&apos;].toString() + &quot;&amp;&quot; +
                                     msg[&apos;OBR&apos;][&apos;OBR.3&apos;][&apos;OBR.3.4&apos;].toString();


    // Mirth apparently cannot support deeper than seg.x.y, so it&apos;s necessary to 
    // handle the subdivisions of the fields beyond this using split().
    var specSrcList = msg[&apos;OBR&apos;][&apos;OBR.15&apos;][&apos;OBR.15.1&apos;].toString().split(&quot;&amp;&quot;);
    if (specSrcList.length &gt;= 3)
    {
      msg[&apos;SPM&apos;][&apos;SPM.4&apos;][&apos;SPM.4.1&apos;] = specSrcList[0]; // OBR.15.1.1
      msg[&apos;SPM&apos;][&apos;SPM.4&apos;][&apos;SPM.4.2&apos;] = specSrcList[1]; // OBR.15.1.2
      msg[&apos;SPM&apos;][&apos;SPM.4&apos;][&apos;SPM.4.3&apos;] = specSrcList[2]; // OBR.15.1.3
    }

    var bodySiteList = msg[&apos;OBR&apos;][&apos;OBR.15&apos;][&apos;OBR.15.4&apos;].toString().split(&quot;&amp;&quot;);
    if (bodySiteList.length &gt;= 3)
    {
      msg[&apos;SPM&apos;][&apos;SPM.8&apos;][&apos;SPM.8.1&apos;] = bodySiteList[0]; // OBR.15.4.1
      msg[&apos;SPM&apos;][&apos;SPM.8&apos;][&apos;SPM.8.2&apos;] = bodySiteList[1]; // OBR.15.4.2
      msg[&apos;SPM&apos;][&apos;SPM.8&apos;][&apos;SPM.8.3&apos;] = bodySiteList[2]; // OBR.15.4.3
    }

    msg[&apos;SPM&apos;][&apos;SPM.17&apos;][&apos;SPM.17.1&apos;] = msg[&apos;OBR&apos;][&apos;OBR.7&apos;][&apos;OBR.7.1&apos;].toString();
    msg[&apos;SPM&apos;][&apos;SPM.18&apos;] = msg[&apos;OBR&apos;][&apos;OBR.14&apos;][&apos;OBR.14.1&apos;].toString();

    msg[&apos;SPM&apos;][&apos;SPM.26&apos;] = &apos;&apos;;
  

    // Remove OBX, re-add OBX.  This should re-order the msg correctly so that OBX is last.
    //var obx = msg[&apos;OBX&apos;];
    //delete msg[&apos;OBX&apos;];
    //msg[&apos;OBX&apos;] = obx;
  }
}
catch(e)
{
  logger.error(&quot;Error in Send result to PHIXConnectorService Transformer: Add SPM Segment: &quot; + e.message);
  channelMap.put(&apos;componentErrors&apos;,  $(&apos;componentErrors&apos;) + &quot;Send result to PHIXConnectorService Transformer: Add SPM Segment: \n&quot; + e.message + &quot; |\n&quot;);
}</script>
            <type>JavaScript</type>
            <data class="map">
              <entry>
                <string>Script</string>
                <string>try
{
  if ($(&apos;addSPMSegment&apos;) == &apos;true&apos;)
  {
    logger.info(&quot;Adding SPM Segment&quot;);

    //var newSPM = createSegment(&apos;SPM&apos;);
    //msg[&apos;OBR&apos;] += newSPM;

    // Create SPM segment, per requirements in &quot;Message Processing Flow&quot; spreadsheet
    // (Not specifying a location should place it last, which is where it belongs)
  
    msg[&apos;SPM&apos;][&apos;SPM.1&apos;] = &apos;1&apos;;
    //msg[&apos;SPM&apos;][&apos;SPM.2&apos;][&apos;SPM.2.2&apos;][&apos;SPM.2.2.1&apos;] = msg[&apos;OBR&apos;][&apos;OBR.3&apos;][&apos;OBR.3.1&apos;];
    //msg[&apos;SPM&apos;][&apos;SPM.2&apos;][&apos;SPM.2.2&apos;][&apos;SPM.2.2.2&apos;] = msg[&apos;OBR&apos;][&apos;OBR.3&apos;][&apos;OBR.3.2&apos;];
    //msg[&apos;SPM&apos;][&apos;SPM.2&apos;][&apos;SPM.2.2&apos;][&apos;SPM.2.2.3&apos;] = msg[&apos;OBR&apos;][&apos;OBR.3&apos;][&apos;OBR.3.3&apos;];
    //msg[&apos;SPM&apos;][&apos;SPM.2&apos;][&apos;SPM.2.2&apos;][&apos;SPM.2.2.4&apos;] = msg[&apos;OBR&apos;][&apos;OBR.3&apos;][&apos;OBR.3.4&apos;];

    msg[&apos;SPM&apos;][&apos;SPM.2&apos;][&apos;SPM.2.2&apos;] = msg[&apos;OBR&apos;][&apos;OBR.3&apos;][&apos;OBR.3.1&apos;].toString() + &quot;&amp;&quot; +
                                     msg[&apos;OBR&apos;][&apos;OBR.3&apos;][&apos;OBR.3.2&apos;].toString() + &quot;&amp;&quot; +
                                     msg[&apos;OBR&apos;][&apos;OBR.3&apos;][&apos;OBR.3.3&apos;].toString() + &quot;&amp;&quot; +
                                     msg[&apos;OBR&apos;][&apos;OBR.3&apos;][&apos;OBR.3.4&apos;].toString();


    // Mirth apparently cannot support deeper than seg.x.y, so it&apos;s necessary to 
    // handle the subdivisions of the fields beyond this using split().
    var specSrcList = msg[&apos;OBR&apos;][&apos;OBR.15&apos;][&apos;OBR.15.1&apos;].toString().split(&quot;&amp;&quot;);
    if (specSrcList.length &gt;= 3)
    {
      msg[&apos;SPM&apos;][&apos;SPM.4&apos;][&apos;SPM.4.1&apos;] = specSrcList[0]; // OBR.15.1.1
      msg[&apos;SPM&apos;][&apos;SPM.4&apos;][&apos;SPM.4.2&apos;] = specSrcList[1]; // OBR.15.1.2
      msg[&apos;SPM&apos;][&apos;SPM.4&apos;][&apos;SPM.4.3&apos;] = specSrcList[2]; // OBR.15.1.3
    }

    var bodySiteList = msg[&apos;OBR&apos;][&apos;OBR.15&apos;][&apos;OBR.15.4&apos;].toString().split(&quot;&amp;&quot;);
    if (bodySiteList.length &gt;= 3)
    {
      msg[&apos;SPM&apos;][&apos;SPM.8&apos;][&apos;SPM.8.1&apos;] = bodySiteList[0]; // OBR.15.4.1
      msg[&apos;SPM&apos;][&apos;SPM.8&apos;][&apos;SPM.8.2&apos;] = bodySiteList[1]; // OBR.15.4.2
      msg[&apos;SPM&apos;][&apos;SPM.8&apos;][&apos;SPM.8.3&apos;] = bodySiteList[2]; // OBR.15.4.3
    }

    msg[&apos;SPM&apos;][&apos;SPM.17&apos;][&apos;SPM.17.1&apos;] = msg[&apos;OBR&apos;][&apos;OBR.7&apos;][&apos;OBR.7.1&apos;].toString();
    msg[&apos;SPM&apos;][&apos;SPM.18&apos;] = msg[&apos;OBR&apos;][&apos;OBR.14&apos;][&apos;OBR.14.1&apos;].toString();

    msg[&apos;SPM&apos;][&apos;SPM.26&apos;] = &apos;&apos;;
  

    // Remove OBX, re-add OBX.  This should re-order the msg correctly so that OBX is last.
    //var obx = msg[&apos;OBX&apos;];
    //delete msg[&apos;OBX&apos;];
    //msg[&apos;OBX&apos;] = obx;
  }
}
catch(e)
{
  logger.error(&quot;Error in Send result to PHIXConnectorService Transformer: Add SPM Segment: &quot; + e.message);
  channelMap.put(&apos;componentErrors&apos;,  $(&apos;componentErrors&apos;) + &quot;Send result to PHIXConnectorService Transformer: Add SPM Segment: \n&quot; + e.message + &quot; |\n&quot;);
}</string>
              </entry>
            </data>
          </step>
          <step>
            <sequenceNumber>3</sequenceNumber>
            <name>ORU R01 2.3.1 to 2.5.1 Transformation</name>
            <script>try
{
  // 2.3.1 to 2.5.1 ORU R01-specific MSH transformations
  if ( ($(&apos;translateToVersion&apos;) == &apos;2.5.1&apos;) &amp;&amp;
       ($(&apos;msgType&apos;) == &apos;ORU&apos;) &amp;&amp;
       ($(&apos;msgTriggerEvent&apos;) == &apos;R01&apos;) &amp;&amp;
       ($(&apos;msgHL7VersionID&apos;) == &apos;2.3.1&apos;) )
  {
    logger.info(&quot;Transforming ORU R01 2.3.1 message to 2.5.1&quot;);

    // MSH additions
    msg[&apos;MSH&apos;][&apos;MSH.12&apos;] = &apos;2.5.1&apos;;&#xd;
    msg[&apos;MSH&apos;][&apos;MSH.9&apos;][&apos;MSH.9.3&apos;] = &apos;ORU_R01&apos;;&#xd;
    msg[&apos;MSH&apos;][&apos;MSH.21&apos;][&apos;MSH.21.1&apos;] = &apos;V251_IG_LB_LABRPTPH_R1_INFORM_2010FEB&apos;;
    msg[&apos;MSH&apos;][&apos;MSH.21&apos;][&apos;MSH.21.2&apos;] = &apos;&apos;;
    msg[&apos;MSH&apos;][&apos;MSH.21&apos;][&apos;MSH.21.3&apos;] = &apos;2.16.840.1.114222.4.3.2.5.2.5&apos;;
    msg[&apos;MSH&apos;][&apos;MSH.21&apos;][&apos;MSH.21.4&apos;] = &apos;ISO&apos;;

    // OBR deletions
    msg[&apos;OBR&apos;][&apos;OBR.14&apos;] = &apos;&apos;;
    msg[&apos;OBR&apos;][&apos;OBR.15&apos;] = &apos;&apos;;

    // OBX additions
    msg[&apos;OBX&apos;][&apos;OBX.23&apos;] = &quot;INFORMATION NOT AVAILABLE&quot;;
    msg[&apos;OBX&apos;][&apos;OBX.24&apos;][&apos;OBX.24.1&apos;] = &quot;INFORMATION NOT AVAILABLE&quot;;
    msg[&apos;OBX&apos;][&apos;OBX.24&apos;][&apos;OBX.24.2&apos;] = &apos;&apos;;
    msg[&apos;OBX&apos;][&apos;OBX.24&apos;][&apos;OBX.24.3&apos;] = &apos;&apos;;
    msg[&apos;OBX&apos;][&apos;OBX.24&apos;][&apos;OBX.24.4&apos;] = &apos;&apos;;
    msg[&apos;OBX&apos;][&apos;OBX.24&apos;][&apos;OBX.24.5&apos;] = &apos;&apos;;
  }
}
catch(e)
{
  logger.error(&quot;Error in Send result to PHIXConnectorService Transformer: ORU R01 2.3.1 to 2.5.1 Transformation: &quot; + e.message);
  channelMap.put(&apos;componentErrors&apos;,  $(&apos;componentErrors&apos;) + &quot;Send result to PHIXConnectorService Transformer: ORU R01 2.3.1 to 2.5.1 Transformation: \n&quot; + e.message + &quot; |\n&quot;);
}</script>
            <type>JavaScript</type>
            <data class="map">
              <entry>
                <string>Script</string>
                <string>try
{
  // 2.3.1 to 2.5.1 ORU R01-specific MSH transformations
  if ( ($(&apos;translateToVersion&apos;) == &apos;2.5.1&apos;) &amp;&amp;
       ($(&apos;msgType&apos;) == &apos;ORU&apos;) &amp;&amp;
       ($(&apos;msgTriggerEvent&apos;) == &apos;R01&apos;) &amp;&amp;
       ($(&apos;msgHL7VersionID&apos;) == &apos;2.3.1&apos;) )
  {
    logger.info(&quot;Transforming ORU R01 2.3.1 message to 2.5.1&quot;);

    // MSH additions
    msg[&apos;MSH&apos;][&apos;MSH.12&apos;] = &apos;2.5.1&apos;;&#xd;
    msg[&apos;MSH&apos;][&apos;MSH.9&apos;][&apos;MSH.9.3&apos;] = &apos;ORU_R01&apos;;&#xd;
    msg[&apos;MSH&apos;][&apos;MSH.21&apos;][&apos;MSH.21.1&apos;] = &apos;V251_IG_LB_LABRPTPH_R1_INFORM_2010FEB&apos;;
    msg[&apos;MSH&apos;][&apos;MSH.21&apos;][&apos;MSH.21.2&apos;] = &apos;&apos;;
    msg[&apos;MSH&apos;][&apos;MSH.21&apos;][&apos;MSH.21.3&apos;] = &apos;2.16.840.1.114222.4.3.2.5.2.5&apos;;
    msg[&apos;MSH&apos;][&apos;MSH.21&apos;][&apos;MSH.21.4&apos;] = &apos;ISO&apos;;

    // OBR deletions
    msg[&apos;OBR&apos;][&apos;OBR.14&apos;] = &apos;&apos;;
    msg[&apos;OBR&apos;][&apos;OBR.15&apos;] = &apos;&apos;;

    // OBX additions
    msg[&apos;OBX&apos;][&apos;OBX.23&apos;] = &quot;INFORMATION NOT AVAILABLE&quot;;
    msg[&apos;OBX&apos;][&apos;OBX.24&apos;][&apos;OBX.24.1&apos;] = &quot;INFORMATION NOT AVAILABLE&quot;;
    msg[&apos;OBX&apos;][&apos;OBX.24&apos;][&apos;OBX.24.2&apos;] = &apos;&apos;;
    msg[&apos;OBX&apos;][&apos;OBX.24&apos;][&apos;OBX.24.3&apos;] = &apos;&apos;;
    msg[&apos;OBX&apos;][&apos;OBX.24&apos;][&apos;OBX.24.4&apos;] = &apos;&apos;;
    msg[&apos;OBX&apos;][&apos;OBX.24&apos;][&apos;OBX.24.5&apos;] = &apos;&apos;;
  }
}
catch(e)
{
  logger.error(&quot;Error in Send result to PHIXConnectorService Transformer: ORU R01 2.3.1 to 2.5.1 Transformation: &quot; + e.message);
  channelMap.put(&apos;componentErrors&apos;,  $(&apos;componentErrors&apos;) + &quot;Send result to PHIXConnectorService Transformer: ORU R01 2.3.1 to 2.5.1 Transformation: \n&quot; + e.message + &quot; |\n&quot;);
}</string>
              </entry>
            </data>
          </step>
        </steps>
        <inboundTemplate encoding="base64"></inboundTemplate>
        <outboundTemplate encoding="base64"></outboundTemplate>
        <inboundProtocol>HL7V2</inboundProtocol>
        <outboundProtocol>HL7V2</outboundProtocol>
        <inboundProperties>
          <property name="convertLFtoCR">true</property>
          <property name="handleRepetitions">false</property>
          <property name="handleSubcomponents">false</property>
          <property name="stripNamespaces">true</property>
          <property name="useStrictParser">false</property>
          <property name="useStrictValidation">false</property>
        </inboundProperties>
        <outboundProperties>
          <property name="convertLFtoCR">true</property>
          <property name="handleRepetitions">false</property>
          <property name="handleSubcomponents">false</property>
          <property name="stripNamespaces">true</property>
          <property name="useStrictParser">false</property>
          <property name="useStrictValidation">false</property>
        </outboundProperties>
      </transformer>
      <filter>
        <rules>
          <rule>
            <sequenceNumber>0</sequenceNumber>
            <name>filter to determine if msg needs to be sent to PHIXConnectorService</name>
            <data class="map">
              <entry>
                <string>Script</string>
                <string>var retval = false;

if ($(&apos;enablePHIXPortalConnector&apos;) != &apos;true&apos;)
{
  logger.info(&quot;Bypassing PHIXConnectorService call based on PHIX configuration&quot;);
}
else
{
  logger.info(&quot;Calling PHIXConnectorService&quot;);
  retval = true;
}

if (retval)
{
  channelMap.put(&apos;phixConnectorServiceCallStatus&apos;, &apos;CALLED&apos;);
}
else
{
  channelMap.put(&apos;phixConnectorServiceCallStatus&apos;, &apos;BYPASSED&apos;);
}

return retval;</string>
              </entry>
            </data>
            <type>JavaScript</type>
            <script>var retval = false;

if ($(&apos;enablePHIXPortalConnector&apos;) != &apos;true&apos;)
{
  logger.info(&quot;Bypassing PHIXConnectorService call based on PHIX configuration&quot;);
}
else
{
  logger.info(&quot;Calling PHIXConnectorService&quot;);
  retval = true;
}

if (retval)
{
  channelMap.put(&apos;phixConnectorServiceCallStatus&apos;, &apos;CALLED&apos;);
}
else
{
  channelMap.put(&apos;phixConnectorServiceCallStatus&apos;, &apos;BYPASSED&apos;);
}

return retval;</script>
            <operator>NONE</operator>
          </rule>
        </rules>
      </filter>
      <transportName>Web Service Sender</transportName>
      <mode>DESTINATION</mode>
      <enabled>false</enabled>
      <version>2.2.0.5828</version>
    </connector>
    <connector>
      <name>Send email alert for detected notifiable condition</name>
      <properties>
        <property name="DataType">SMTP Sender</property>
        <property name="attachments">&lt;list/&gt;</property>
        <property name="authentication">0</property>
        <property name="body">This email notification is being sent to alert you that laboratory test results were received that have met Notifiable Disease Condition criteria and to inform you of the need to initiate Public Case Reporting.

Notification Program: ${subscriptionDesc}

Test Code: ${stdObx31}
Test Description: ${stdObx32}
Result Code: ${obx51}
Result Description: ${obx52}

Placer Order Number (Entity ID): ${placerOrderNumberEntityID}


Please do not respond to this automated email notification.
</property>
        <property name="charsetEncoding">DEFAULT_ENCODING</property>
        <property name="encryption">none</property>
        <property name="from">${hubInstanceEmailFromAddr}</property>
        <property name="headers">&lt;linked-hash-map/&gt;</property>
        <property name="html">0</property>
        <property name="password"></property>
        <property name="smtpHost">localhost</property>
        <property name="smtpPort">25</property>
        <property name="subject">PHIX- notifiable condition alert</property>
        <property name="timeout">5000</property>
        <property name="to">${sendingFacilityNotificationEmail}</property>
        <property name="username"></property>
      </properties>
      <transformer>
        <steps/>
        <inboundTemplate encoding="base64"></inboundTemplate>
        <inboundProtocol>HL7V2</inboundProtocol>
        <outboundProtocol>HL7V2</outboundProtocol>
        <inboundProperties>
          <property name="convertLFtoCR">true</property>
          <property name="handleRepetitions">false</property>
          <property name="handleSubcomponents">false</property>
          <property name="stripNamespaces">true</property>
          <property name="useStrictParser">false</property>
          <property name="useStrictValidation">false</property>
        </inboundProperties>
        <outboundProperties>
          <property name="convertLFtoCR">true</property>
          <property name="handleRepetitions">false</property>
          <property name="handleSubcomponents">false</property>
          <property name="stripNamespaces">true</property>
          <property name="useStrictParser">false</property>
          <property name="useStrictValidation">false</property>
        </outboundProperties>
      </transformer>
      <filter>
        <rules>
          <rule>
            <sequenceNumber>0</sequenceNumber>
            <name>Filter for subscription matches</name>
            <data class="map">
              <entry>
                <string>Script</string>
                <string>var retval = ($(&apos;subscription&apos;) == &apos;true&apos; &amp;&amp; 
              $(&apos;subscriptionName&apos;).length() &gt; 0 &amp;&amp;
              $(&apos;hubHost&apos;) == $(&apos;receivingFacilityHubHost&apos;) &amp;&amp;
              !($(&apos;componentErrors&apos;).length() &gt; 0) );

if (retval)
{
  channelMap.put(&apos;emailAlertStatus&apos;, &apos;SENT&apos;);
}
else
{
  channelMap.put(&apos;emailAlertStatus&apos;, &apos;BYPASSED&apos;);
}

return retval;</string>
              </entry>
            </data>
            <type>JavaScript</type>
            <script>var retval = ($(&apos;subscription&apos;) == &apos;true&apos; &amp;&amp; 
              $(&apos;subscriptionName&apos;).length() &gt; 0 &amp;&amp;
              $(&apos;hubHost&apos;) == $(&apos;receivingFacilityHubHost&apos;) &amp;&amp;
              !($(&apos;componentErrors&apos;).length() &gt; 0) );

if (retval)
{
  channelMap.put(&apos;emailAlertStatus&apos;, &apos;SENT&apos;);
}
else
{
  channelMap.put(&apos;emailAlertStatus&apos;, &apos;BYPASSED&apos;);
}

return retval;</script>
            <operator>NONE</operator>
          </rule>
        </rules>
      </filter>
      <transportName>SMTP Sender</transportName>
      <mode>DESTINATION</mode>
      <enabled>false</enabled>
      <version>2.2.0.5828</version>
    </connector>
    <connector>
      <name>Log events</name>
      <properties>
        <property name="DataType">File Writer</property>
        <property name="FTPAnonymous">1</property>
        <property name="binary">0</property>
        <property name="charsetEncoding">DEFAULT_ENCODING</property>
        <property name="directory"></property>
        <property name="errorOnExists">0</property>
        <property name="host">C:/phixdata/logs</property>
        <property name="outputAppend">1</property>
        <property name="outputPattern">phix_events.log</property>
        <property name="passive">1</property>
        <property name="password">anonymous</property>
        <property name="scheme">file</property>
        <property name="secure">1</property>
        <property name="template">-----------------------------------------------------------------------------
Date: ${date.get(&apos;MM/dd/yyyy HH:mm:ss&apos;)}
Message DateTime: ${msgDateTime}
Message Control ID: ${msgCtrlID}
HL7 version: ${msgHL7VersionID}  Type: ${msgType}  Event: ${msgTriggerEvent}  
Sending Facility ID: ${msgSendingFacilityID},  Receiving Facility ID: ${msgReceivingFacilityID}
Incoming Filename: ${timestamp}_IN.txt  Transformed Filename: ${timestamp}_XFORMED.txt

Site Configuration:
  hubInstanceName: ${hubInstanceName}
  hubHost: ${hubHost}
  hubInstanceEmailFromAddr: ${hubInstanceEmailFromAddr}
  hubInstanceWebSvcHost: ${hubInstanceWebSvcHost}

Msg Configuration:
  structural validation: ${structuralValidation}
  vocabTranslation: ${vocabTranslation}
  codeValidation: ${codeValidation}
  subscription: ${subscription}
  anonymization: ${anonymization}
  addSFTSegment: ${addSFTSegment}
  addSPMSegment: ${addSPMSegment}
  translateToVersion: ${translateToVersion}
  vocabTranslationMSSProfile: ${vocabTranslationMSSProfile}
  codeValidationMSSProfile: ${codeValidationMSSProfile}
  customProfileName: ${customProfileName}
  sendingFacilityDirectEmailAddress: ${sendingFacilityDirectEmailAddress}
  sendingFacilityNotificationEmail: ${sendingFacilityNotificationEmail}
  sendingFacilityErrorNotificationEmail: ${sendingFacilityErrorNotificationEmail}
  sendingFacilityWebSvcHost: ${receivingFacilityWebSvcHost}
  sendingFacilityXportType: ${receivingFacilityXportType}
  sendingFacilityHubHost: ${receivingFacilityHubHost}
  receivingFacilityDirectEmailAddress: ${sendingFacilityDirectEmailAddress}
  receivingFacilityWebSvcHost: ${sendingFacilityWebSvcHost}
  receivingFacilityXportType: ${sendingFacilityXportType}
  receivingFacilityHubHost: ${receivingFacilityHubHost}

Services:
  Component Routing Service: CALLED
  Dynamic Msg Sender: ${dynamicMsgSendingFacStatus}
  Dynamic Msg Receiver: ${dynamicMsgReceivingFacStatus}
  Structural Validation Service: ${strucutralValidationCallStatus}
  Vocabulary Translation Service: ${vocabTranslationCallStatus}
  Code Validation Service: ${codeValidationCallStatus}
  Subscription Service: ${subscriptionCallStatus}
  Linker/Anonymizer Service: ${anonymizationCallStatus}
  ACK Message: ${ackSentStatus}
  Outgoing Message: ${outgoingMsgSentStatus}
  PHIX Connector Service: ${phixConnectorServiceCallStatus}
  Notifiable Condition Email Alert: ${emailAlertStatus}

Errors:
${componentErrors}
</property>
        <property name="temporary">0</property>
        <property name="timeout">10000</property>
        <property name="username">anonymous</property>
        <property name="validateConnections">1</property>
      </properties>
      <transformer>
        <steps/>
        <inboundTemplate encoding="base64"></inboundTemplate>
        <inboundProtocol>HL7V2</inboundProtocol>
        <outboundProtocol>HL7V2</outboundProtocol>
        <inboundProperties>
          <property name="convertLFtoCR">true</property>
          <property name="handleRepetitions">false</property>
          <property name="handleSubcomponents">false</property>
          <property name="stripNamespaces">true</property>
          <property name="useStrictParser">false</property>
          <property name="useStrictValidation">false</property>
        </inboundProperties>
        <outboundProperties>
          <property name="convertLFtoCR">true</property>
          <property name="handleRepetitions">false</property>
          <property name="handleSubcomponents">false</property>
          <property name="stripNamespaces">true</property>
          <property name="useStrictParser">false</property>
          <property name="useStrictValidation">false</property>
        </outboundProperties>
      </transformer>
      <filter>
        <rules/>
      </filter>
      <transportName>File Writer</transportName>
      <mode>DESTINATION</mode>
      <enabled>true</enabled>
      <version>2.2.0.5828</version>
    </connector>
    <connector>
      <name>Log errors</name>
      <properties>
        <property name="DataType">File Writer</property>
        <property name="FTPAnonymous">1</property>
        <property name="binary">0</property>
        <property name="charsetEncoding">DEFAULT_ENCODING</property>
        <property name="directory"></property>
        <property name="errorOnExists">0</property>
        <property name="host">C:/phixdata/logs</property>
        <property name="outputAppend">1</property>
        <property name="outputPattern">phix_errors.log</property>
        <property name="passive">1</property>
        <property name="password">anonymous</property>
        <property name="scheme">file</property>
        <property name="secure">1</property>
        <property name="template">-----------------------------------------------------------------------------
Date: ${date.get(&apos;MM/dd/yyyy HH:mm:ss&apos;)}
Message DateTime: ${msgDateTime}
Message Control ID: ${msgCtrlID}
HL7 version: ${msgHL7VersionID}  Type: ${msgType}  Event: ${msgTriggerEvent}  
Sending Facility ID: ${msgSendingFacilityID},  Receiving Facility ID: ${msgReceivingFacilityID}
Incoming Filename: ${timestamp}_IN.txt  Transformed Filename: ${timestamp}_XFORMED.txt
Errors:
${componentErrors}

</property>
        <property name="temporary">0</property>
        <property name="timeout">10000</property>
        <property name="username">anonymous</property>
        <property name="validateConnections">1</property>
      </properties>
      <transformer>
        <steps/>
        <inboundTemplate encoding="base64"></inboundTemplate>
        <inboundProtocol>HL7V2</inboundProtocol>
        <outboundProtocol>HL7V2</outboundProtocol>
        <inboundProperties>
          <property name="convertLFtoCR">true</property>
          <property name="handleRepetitions">false</property>
          <property name="handleSubcomponents">false</property>
          <property name="stripNamespaces">true</property>
          <property name="useStrictParser">false</property>
          <property name="useStrictValidation">false</property>
        </inboundProperties>
        <outboundProperties>
          <property name="convertLFtoCR">true</property>
          <property name="handleRepetitions">false</property>
          <property name="handleSubcomponents">false</property>
          <property name="stripNamespaces">true</property>
          <property name="useStrictParser">false</property>
          <property name="useStrictValidation">false</property>
        </outboundProperties>
      </transformer>
      <filter>
        <rules>
          <rule>
            <sequenceNumber>0</sequenceNumber>
            <name>Filter destination based on component errors being present</name>
            <data class="map">
              <entry>
                <string>Script</string>
                <string>return $(&apos;componentErrors&apos;).length() &gt; 0;</string>
              </entry>
            </data>
            <type>JavaScript</type>
            <script>return $(&apos;componentErrors&apos;).length() &gt; 0;</script>
            <operator>NONE</operator>
          </rule>
        </rules>
      </filter>
      <transportName>File Writer</transportName>
      <mode>DESTINATION</mode>
      <enabled>true</enabled>
      <version>2.2.0.5828</version>
    </connector>
    <connector>
      <name>Email errors</name>
      <properties>
        <property name="DataType">SMTP Sender</property>
        <property name="attachments">&lt;list/&gt;</property>
        <property name="authentication">0</property>
        <property name="body">This email notification is being sent to alert you that a message sent by your organization failed to process correctly.

Message DateTime: ${msgDateTime}
Message Control ID: ${msgCtrlID}
HL7 version: ${msgHL7VersionID}  Type: ${msgType}  Event: ${msgTriggerEvent}
Incoming Filename: ${timestamp}_IN.txt  Transformed Filename: ${timestamp}_XFORMED.txt
Errors:
${componentErrors}

Please do not respond to this automated email notification.
</property>
        <property name="charsetEncoding">DEFAULT_ENCODING</property>
        <property name="encryption">none</property>
        <property name="from">${hubInstanceEmailFromAddr}</property>
        <property name="headers">&lt;linked-hash-map/&gt;</property>
        <property name="html">0</property>
        <property name="password"></property>
        <property name="smtpHost">localhost</property>
        <property name="smtpPort">25</property>
        <property name="subject">PHIX- error processing message</property>
        <property name="timeout">5000</property>
        <property name="to">${sendingFacilityErrorNotificationEmail}</property>
        <property name="username"></property>
      </properties>
      <transformer>
        <steps/>
        <inboundTemplate encoding="base64"></inboundTemplate>
        <inboundProtocol>HL7V2</inboundProtocol>
        <outboundProtocol>HL7V2</outboundProtocol>
        <inboundProperties>
          <property name="convertLFtoCR">true</property>
          <property name="handleRepetitions">false</property>
          <property name="handleSubcomponents">false</property>
          <property name="stripNamespaces">true</property>
          <property name="useStrictParser">false</property>
          <property name="useStrictValidation">false</property>
        </inboundProperties>
        <outboundProperties>
          <property name="convertLFtoCR">true</property>
          <property name="handleRepetitions">false</property>
          <property name="handleSubcomponents">false</property>
          <property name="stripNamespaces">true</property>
          <property name="useStrictParser">false</property>
          <property name="useStrictValidation">false</property>
        </outboundProperties>
      </transformer>
      <filter>
        <rules>
          <rule>
            <sequenceNumber>0</sequenceNumber>
            <name>Filter for presence of errors and an email address</name>
            <data class="map">
              <entry>
                <string>Script</string>
                <string>return ($(&apos;componentErrors&apos;).length() &gt; 0 &amp;&amp;
        $(&apos;sendingFacilityErrorNotificationEmail&apos;) != &quot;NONE&quot;);</string>
              </entry>
            </data>
            <type>JavaScript</type>
            <script>return ($(&apos;componentErrors&apos;).length() &gt; 0 &amp;&amp;
        $(&apos;sendingFacilityErrorNotificationEmail&apos;) != &quot;NONE&quot;);</script>
            <operator>NONE</operator>
          </rule>
        </rules>
      </filter>
      <transportName>SMTP Sender</transportName>
      <mode>DESTINATION</mode>
      <enabled>false</enabled>
      <version>2.2.0.5828</version>
    </connector>
    <connector>
      <name>Processing complete</name>
      <properties>
        <property name="DataType">Channel Writer</property>
        <property name="host">sink</property>
        <property name="synchronised">0</property>
        <property name="template">${message.encodedData}</property>
      </properties>
      <transformer>
        <steps>
          <step>
            <sequenceNumber>0</sequenceNumber>
            <name>Log processing complete</name>
            <script>logger.info(&quot;Message processing complete.&quot;);</script>
            <type>JavaScript</type>
            <data class="map">
              <entry>
                <string>Script</string>
                <string>logger.info(&quot;Message processing complete.&quot;);</string>
              </entry>
            </data>
          </step>
        </steps>
        <inboundTemplate encoding="base64"></inboundTemplate>
        <outboundTemplate encoding="base64"></outboundTemplate>
        <inboundProtocol>HL7V2</inboundProtocol>
        <outboundProtocol>HL7V2</outboundProtocol>
        <inboundProperties>
          <property name="convertLFtoCR">true</property>
          <property name="handleRepetitions">false</property>
          <property name="handleSubcomponents">false</property>
          <property name="stripNamespaces">true</property>
          <property name="useStrictParser">false</property>
          <property name="useStrictValidation">false</property>
        </inboundProperties>
        <outboundProperties>
          <property name="convertLFtoCR">true</property>
          <property name="handleRepetitions">false</property>
          <property name="handleSubcomponents">false</property>
          <property name="stripNamespaces">true</property>
          <property name="useStrictParser">false</property>
          <property name="useStrictValidation">false</property>
        </outboundProperties>
      </transformer>
      <filter>
        <rules/>
      </filter>
      <transportName>Channel Writer</transportName>
      <mode>DESTINATION</mode>
      <enabled>true</enabled>
      <version>2.2.0.5828</version>
    </connector>
  </destinationConnectors>
  <properties>
    <property name="clearGlobalChannelMap">true</property>
    <property name="dont_store_filtered">false</property>
    <property name="encryptData">false</property>
    <property name="error_messages_only">false</property>
    <property name="initialState">started</property>
    <property name="max_message_age">-1</property>
    <property name="store_messages">true</property>
    <property name="synchronous">true</property>
    <property name="transactional">false</property>
  </properties>
  <preprocessingScript>// Modify the message variable below to pre process data
return message;</preprocessingScript>
  <postprocessingScript>// This script executes once after a message has been processed
return;</postprocessingScript>
  <deployScript>// This script executes once when the channel is deployed
// You only have access to the globalMap and globalChannelMap here to persist data
return;</deployScript>
  <shutdownScript>// This script executes once when the channel is undeployed
// You only have access to the globalMap and globalChannelMap here to persist data
return;</shutdownScript>
</channel>